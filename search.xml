<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HTML 基础篇</title>
    <url>/2022/09/07/HTML%20base/</url>
    <content><![CDATA[<h1 id="HTML-基础总结"><a href="#HTML-基础总结" class="headerlink" title="HTML 基础总结"></a>HTML 基础总结</h1><h2 id="SEO-相关内容"><a href="#SEO-相关内容" class="headerlink" title="SEO 相关内容"></a>SEO 相关内容</h2><p>所谓 SEO ，就是搜索引擎索引优化，让搜索引擎更容易定位到网站内容，然而对于一个网站，最重要的便是 HTML，提供完整的内容是 web 出现的首要原因，一个好的网站不应该脱离内容，功能主体。</p>
<h3 id="1-HTML-语义化的理解"><a href="#1-HTML-语义化的理解" class="headerlink" title="1. HTML 语义化的理解"></a>1. HTML 语义化的理解</h3><p>Web语义化是指使用恰当语义的<code>html</code>标签、<code>class</code>类名等内容，让页面具有良好的结构与含义，从而让人和机器都能快速理解网页内容。语义化的<code>web</code>页面一方面可以让机器在更少的人类干预情况下收集并研究网页的信息，从而可以读懂网页的内容，然后将收集汇总的信息进行分析，结果为人类所用；另一方面它可以让开发人员读懂结构和用户以及屏幕阅读器（如果访客有视障）能够读懂内容。</p>
<p>简而言之，一种 <code>Web </code>开发规范，规范的作用就有：</p>
<ol>
<li>更好的维护项目，提高代码可读性。</li>
<li>机器更容易理解内容，那么对于 <code>SEO</code>,<code>Aria </code>都有帮助，同时有利于编译器进行一系列优化。</li>
</ol>
<h3 id="2-h1-标签和-title-标签之间的区别是什么？"><a href="#2-h1-标签和-title-标签之间的区别是什么？" class="headerlink" title="2. h1 标签和 title 标签之间的区别是什么？"></a>2. h1 标签和 title 标签之间的区别是什么？</h3><ul>
<li><code>h1</code>标签：写在文章正文的标题部分，参与文章的内容部分，对于一个页面最好只有一个主题，更好彰显主题。</li>
<li><code>title</code>标签：写在网页的 <code>head</code> 部分，不参与文章的内容，是展示给搜索引擎的，对于 <code>SEO</code> 而言其权重无疑是最大的，其次，会作为浏览器标签卡，并会保留在历史记录中。</li>
</ul>
<h3 id="3-lt-img-x2F-gt-中的-title-属性和-alt-属性的区别"><a href="#3-lt-img-x2F-gt-中的-title-属性和-alt-属性的区别" class="headerlink" title="3. <img /> 中的 title 属性和 alt 属性的区别"></a>3. &lt;img /&gt; 中的 title 属性和 alt 属性的区别</h3><p><code>alt</code> 属性是在图片无法加载的时候才会显示的代替文本，对于 <code>alt</code> 的作用是易用性的一个重要信息，屏幕阅读器会提示出来，而 <code>title</code> 是关于元素的注释信息，主要是给用户解读，当鼠标放到文字或是图片上时有 <code>title</code> 文字显示。这两者的区别就类似于我们所说的 <code>em</code>和 <code>strong</code> 的区别</p>
]]></content>
      <categories>
        <category>HTML</category>
        <category>2023面试</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>2023面试</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统知识点总结-进程管理</title>
    <url>/2022/09/09/os-process/</url>
    <content><![CDATA[<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><blockquote>
<p>进程是资源分配的基本单位。</p>
<p>进程控制块(Process Control Block PCB)描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 <code>PCB</code> 的操作。</p>
</blockquote>
<p>进程控制块包含下列信息：</p>
<h5 id="1-进程标识符（PID）"><a href="#1-进程标识符（PID）" class="headerlink" title="1. 进程标识符（PID）"></a>1. 进程标识符（PID）</h5><p>进程标识符用于唯一地标识一个进程。</p>
<p>一个进程通常由两种标识符组成：</p>
<ul>
<li><h6 id="内部标识符："><a href="#内部标识符：" class="headerlink" title="内部标识符："></a>内部标识符：</h6></li>
</ul>
<p>在所有操作系统中，都为每一个进程赋予了一个唯一的数字标识符，它通常是一个进程的序号，设置内部标识符主要是为了方便系统使用。</p>
<ul>
<li><h6 id="外部标识符："><a href="#外部标识符：" class="headerlink" title="外部标识符："></a>外部标识符：</h6></li>
</ul>
<p>它由创建者提供，通常是由字母、数字组成，往往是由用户（进程）在访问该进程时使用，为了描述进程的家族关系，还应设置父进程标识及子进程标识。此外，还可以设置用户标识，以标识拥有该进程的用户。</p>
<p>可以参考一个指令 </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">kill</span> pid <br><span class="hljs-built_in">kill</span> p_name<br></code></pre></td></tr></table></figure>

<h5 id="2-处理机状态"><a href="#2-处理机状态" class="headerlink" title="2. 处理机状态"></a>2. 处理机状态</h5><p>处理机状态信息主要由处理机的各种寄存器的内容组成。</p>
<p>包括： <code>通用寄存器</code>、<code>指令计数器</code>、<code>程序状态字 PSW </code>、<code>用户栈指针</code></p>
<p>这些信息显然和进程相关，因此，进程一旦被中断，就必须把这些信息保存在 <code>PCB</code> 中，以便在恢复运行时能完全恢复中断前的状态。</p>
<h5 id="3-进程调度信息"><a href="#3-进程调度信息" class="headerlink" title="3. 进程调度信息"></a>3. 进程调度信息</h5><p>在 PCB 中还存放一些进程调度和进程对换相关的信息。</p>
<p>包括：<code>进程状态</code>、<code>进程优先级</code>、<code>进程调度所需要的其他信息</code>（所采用的进程调度算法有关），<code>事件</code>（指进程由执行状态变为阻塞态所等待发生的事件，即阻塞原因）</p>
<h5 id="4-进程控制信息"><a href="#4-进程控制信息" class="headerlink" title="4. 进程控制信息"></a>4. 进程控制信息</h5><ul>
<li><p>程序和数据的地址。</p>
</li>
<li><p>进程同步和通信机制，指实现进程同步和进程通信时必须的机制，如消息队列的指针、信号量等，他们可能全部或部分的放在 <code>PCB</code>中。</p>
</li>
<li><p>资源清单，列出了出 <code>CPU</code>以外的、进程所需的全部资源及已经分配到改进程的资源清单。</p>
</li>
<li><p>链接指针，他给出了本进程（<code>PCB</code>）所在队列的下一个进程的 <code>PCB</code> 的首地址。</p>
</li>
</ul>
<pre class="mermaid">classDiagram
    class PCB
    PCB : +唯一标识符
    PCB : +状态机信息
    PCB : +进程调度信息
    PCB : +进程控制信息</pre>

<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是独立调度的基本单位。</p>
<p>一个进程中可以由多个线程，他们共享进程资源。</p>
<p>比如：QQ和浏览器是两个进程，浏览器中里面由很多线程，竟然刚好探讨到了浏览器的线程，值得一提的是单个页面基本有五种线程构成，包含插件线程，网络请求线程，计时器线程，渲染线程，事件触发线程（DomEvent），JS 线程。这里可以知道线程之间是可以共享资源 (HTML)的，但是浏览器的运行与QQ之间是不可通信的，资源是不共享的，QQ又有自己的进程，其下还有自己的线程。</p>
<h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><ul>
<li>资源</li>
</ul>
<p>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问所属进程的资源</p>
<ul>
<li>调度</li>
</ul>
<p>线程是独立调度的基本单位，在同一个进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换</p>
<ul>
<li>系统开销</li>
</ul>
<p>由于创建或撤销进程时,系统都要为之分配或回收资源，如内存空间，I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。在进行进程切换时，涉及当前执行进程 <code>CPU</code> 环境的保存及新调度进 <code>CPU</code> 环境的设置，而线程切换时只需要设置和保存少量的少量的寄存器内容，故开销也很小。</p>
<ul>
<li>通信方面</li>
</ul>
<p>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 <code>PIC</code>。</p>
<h2 id="进程态的切换"><a href="#进程态的切换" class="headerlink" title="进程态的切换"></a>进程态的切换</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://camo.githubusercontent.com/0398c2bace5b1b0695f5a34f6cfedf6e358db565408abc83dd161de71d3bfec8/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f50726f6365737353746174652e706e67" alt="img"></p>
<ul>
<li><p>就绪状态(<code>ready</code>): 等待被调度</p>
</li>
<li><p>运行状态(<code>running</code>)</p>
</li>
<li><p>阻塞状态(<code>waiting</code>): 等待资源</p>
</li>
</ul>
<blockquote>
<p>需要注意:</p>
<ul>
<li>只有就绪态和运行态可以相互转换,其他的都是单向转换,就绪状态的进程通过调度算法从而获得 <code>CPU</code> 事件,转为运行状态;而运行状态的进程,在分配给他的 CPU 时间片用完之后就会转为就绪状态,等待下一次调度.</li>
<li>阻塞状态是缺少需要的资源从而由运行状态转换而来,但是该资源不包括<code>CPU</code>时间,缺少<code>CPU</code> 时间会从运行态转换为就绪态.</li>
</ul>
</blockquote>
<h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><p>不同环境的调度算法目标不同,因此需要针对不同环境来讨论调度算法.</p>
<h3 id="1-批处理系统"><a href="#1-批处理系统" class="headerlink" title="1. 批处理系统"></a>1. 批处理系统</h3><p>批处理系统没有太多的用户操作,该系统中,调度算法目标是保证吞吐量和周转时间(从提交到终止的时间).</p>
<h4 id="1-1-先来先服务-first-come-fist-serverd-FCFS"><a href="#1-1-先来先服务-first-come-fist-serverd-FCFS" class="headerlink" title="1.1 先来先服务(first-come-fist-serverd FCFS)"></a>1.1 先来先服务(first-come-fist-serverd FCFS)</h4><p>非抢占式的调度算法,按照顺序进行调度.</p>
<p>有利于长作业,但不利于短作业,因为短作业必须一直等待前面的长作业执行完毕才能执行,而长作业又需要执行很长的时间,造成了短作业等待的时间过长.</p>
<p>最优状态,耗时短的作业先被执行:</p>
<pre class="mermaid">sequenceDiagram
    participant work_short_time_1
    participant work_short_time_2
    participant work_long_time_1
    participant worl_long_time_2</pre>

<p>最不利状态,耗时的作业一直占用 <code>CPU</code>,使得最短作业始终无法完成:</p>
<pre class="mermaid">sequenceDiagram
participant work_long_time_1
participant worl_long_time_2
participant work_short_time_1
participant work_short_time_2</pre>



<h4 id="1-2-短作业优先-shortest-job-fist-SJF"><a href="#1-2-短作业优先-shortest-job-fist-SJF" class="headerlink" title="1.2 短作业优先(shortest-job-fist SJF)"></a>1.2 短作业优先(shortest-job-fist SJF)</h4><p>非抢占式的掉段算法,按估计运行时间最短的顺序进行调度.</p>
<p>长作业有可能会饿死,处于一直等待短作业执行完毕的状态.因为如果一直有短作业到来,那么长作业永远得不到调度.</p>
<p>比较优的状态,耗时短的任务总量少于长任务,这样让作业更多的占比完成:</p>
<pre class="mermaid">sequenceDiagram
participant work_short_time
participant work_short_time
participant work_long_time</pre>

<p>不利状态,耗时短的任务总量远大于长任务,那么这样饿死的就是相对较短的长任务了🎃:</p>
<pre class="mermaid">sequenceDiagram
    participant work_short_time
    participant work_short_time_2
    participant .....一堆短任务
    participant work_long_time_1
    participant work_long_time_2</pre>



<h4 id="1-3-最短剩余时间优先-shortest-remaining-time-time-next-SRTN"><a href="#1-3-最短剩余时间优先-shortest-remaining-time-time-next-SRTN" class="headerlink" title="1.3 最短剩余时间优先(shortest remaining time time next SRTN)"></a>1.3 最短剩余时间优先(shortest remaining time time next SRTN)</h4><p>最短作业优先的抢占式版本,按剩余运行时间的顺序调度,当一个新作也到达时,其整个运行时间与当前进程的剩余时间作比较,如果新的进程需要的时间更少,则挂起当前进程,运行新的进程,否则新的进程等待.</p>
<h3 id="2-交互式系统"><a href="#2-交互式系统" class="headerlink" title="2.交互式系统"></a>2.交互式系统</h3>]]></content>
      <tags>
        <tag>基础知识</tag>
        <tag>操作系统，进程管理</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统知识点总结-概览</title>
    <url>/2022/09/08/os/</url>
    <content><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>操作系统个人认为更像是竞争问题，对于 CPU 的算力分配，和进程之间的分配问题，既要高效，又要健壮稳定。</p>
<pre class="mermaid">graph LR
    %% Graph 图，待处理解析展示
    Center((操作系统))
    
    Center --&gt; basePersonility(基本特征)
    basePersonility--&gt;并发
    basePersonility--&gt;共享
    basePersonility--&gt;虚拟
    basePersonility--&gt;异步
    
    Center --&gt; baseFunction(基本功能)
    baseFunction--&gt;进程管理
    baseFunction--&gt;内存管理
    baseFunction--&gt;文件管理
    baseFunction--&gt;设备管理

    Center--根据系统功能分类--&gt;sysInner(内核)
    sysInner--系统功能全在内核--&gt;marco(宏内核)
    sysInner--除核心功能之外的系统功能在内部--&gt;mirco(微内核) 
    sysInner--结合宏内核和微内核的特点--&gt;minixco(混合内核)
    
    Center--&gt;sysCall(系统调用)
    
    Center--&gt;interperter(中断分类)
    interperter--CPU执行指令之外的事件--&gt;外中断
    interperter--CPU执行内部事件引起的事件---&gt;异常
    interperter--在用户程序中使用的系统调用--&gt;陷入</pre>



<h2 id="基础特征"><a href="#基础特征" class="headerlink" title="基础特征"></a>基础特征</h2><h3 id="1-并发"><a href="#1-并发" class="headerlink" title="1. 并发"></a>1. 并发</h3><blockquote>
<p>并发是指宏观上在一段时间内能同时运行多个程序，而并行则是指同一时刻能运行多个指令。</p>
<p>并行需要硬件支持，如多流水线，多核处理器或者分布式计算系统。</p>
<p>操作系统通过引入进程和线程，使得程序能够并发运行。</p>
</blockquote>
<p>并发运行并不是真真的同时完成多个任务，而是 <code>CPU</code> 的高速处理，使得各个任务之间来回进行，完成各个任务，而并行也就是我们实际业务希望解决的问题，但是对应带来的成本问题也就出现了。</p>
<!--TODO: 处理 Hexo 时序图问题--->

<pre class="mermaid">sequenceDiagram
    Note left of A: 进程A
    Note right of B: 进程B
    Note over A,B: CPU 在 AB 之间快速切换</pre>

<h3 id="2-共享"><a href="#2-共享" class="headerlink" title="2. 共享"></a>2. 共享</h3><blockquote>
<p>共享是指系统中的资源可以被多个并发进程共同使用。</p>
<p>主要有两种共享方式：<strong>互斥共享</strong>和<strong>同时共享</strong>。</p>
<p>互斥共享的资源被称为临界资源，特点是同时只能有一个占用，比如对于打印机这种外接设备，在同时只能允许一个进程访问，需要用同步机制实现互斥访问，有点类似队列结构（FIFO）。</p>
</blockquote>
<pre class="mermaid">sequenceDiagram
    participant A
    participant B
    Note over A,B: 按照顺序的去进入同一个进程，或者说叫做被同一个进程依次占有，就像打印机队列那样</pre>



<h3 id="3-虚拟"><a href="#3-虚拟" class="headerlink" title="3. 虚拟"></a>3. 虚拟</h3><blockquote>
<p>虚拟技术把一个物理实体转换为多个逻辑实体。</p>
<p>主要有两种虚拟技术：时（时分复用技术）、空（空分复用技术）。</p>
<p>多个进程能在同一个处理器上并发执行也就利用了时分复用技术，让每一个进程轮流占用处理器，每次只执行一小个时间片，并快速切换。</p>
<p>虚拟内存则是使用了空分复用技术，他将物理内存抽象为地址空间，每一个进程都有各自的地址空间，地址空间的也被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有物理内存的页时，执行页面置换算法，将该页置换到内存中。</p>
<p>虚拟内存的关键问题：主要有调度问题、地址映射问题、替换问题、更新问题（要确保主存与辅存的一致性）</p>
</blockquote>
<p>个人认为，虚拟的好处在于可控，让每一步操作是出于可被控制可被调度的，也就使得可优化，更加稳定。</p>
<h3 id="4-异步"><a href="#4-异步" class="headerlink" title="4. 异步"></a>4. 异步</h3><blockquote>
<p>异步进程不是一次性排队完成，而是走走停停，每一步耗费的时间是不可知的</p>
</blockquote>
<p>异步和同步各自有不同的应用场景，不只是在操作系统上的概念，在各大编程语言上也有不同的信息。</p>
<h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><h3 id="1-进程管理"><a href="#1-进程管理" class="headerlink" title="1. 进程管理"></a>1. 进程管理</h3><blockquote>
<p><strong>进程控制</strong>，<strong>进程同步</strong>，<strong>进程通信</strong>，<strong>死锁处理</strong>，<strong>处理机调度</strong>等；</p>
</blockquote>
<ol>
<li><p>进程控制的主要功能是对系统中所有进程实施有效的管理，它具有创建新进程（<strong>fork</strong>），撤销已有进程，实现进程状态转换的功能；</p>
</li>
<li><p>进程同步，也就是异步环境下的一组并发进程因直接制约而互相发送消息，进行互相合作，互相等待，使得各个进程按一定的速度执行的过程，成为进程间的同步，具有同步关系的一组并发进程称为合作进程，合作进程互相发送的信号成为消息或事件，对这样的消息或者事件给一个名称，则我们可用 wait(消息名)表示经常等待合作进程发来的消息，而用过程 signal(消息名)表示像合作进程发送消息。</p>
<p> 进程同时处理同一串数据，会造成不确定性，有多个进程同时对一个文件进行读写，那么读文件的进程无法确定督导的数据是它本来想要的数据（老数据），还是被修改的数据（新数据 <code>modified data</code>），除此之外，当先读后写的时候，由于缓冲区没有写入数据，读进程无数据可读，就进入了阻塞态。</p>
<p> 这种两个或多个进程读写某些共享数据，而最后的结果却决于进行的精准时序，称为数据竞争，而这种多个程序可以并发执行，但是由于系统资源有限，程序的执行不是一贯到底的，而是以不可预知的速度推进的，这也就是之前说的<strong>异步性</strong>。</p>
<p> 这种受到访问顺序限制的的数据是没有意义的（对于程序运行不能有二义性，也就是某一个状态是确定的），所以为了能够使得进程有一定的顺序来访问数据，从而引入了同步的概念。</p>
<p> 对于资源是如此，对于数据库操作同样也是如此。</p>
<p> 而之前所说的信号，下述便是对于用信号量实现进程同步的步骤，主要分为 PV 两大操作。</p>
<p> <strong>信号量</strong>的作用就是控制多进程共享资源的访问（资源有限并且不共享），其本质是任一时刻只能有一个进程访问临界区（代码）数据更新的代码。</p>
<h4 id="PV操作"><a href="#PV操作" class="headerlink" title="PV操作"></a>PV操作</h4><p> PV操作即是针对信号量进行的相应操作，PV操作由P操作原语和V操作原语组成（原语是不可中断的过程）。</p>
<h4 id="P-操作"><a href="#P-操作" class="headerlink" title="P 操作"></a>P 操作</h4><p> 当进程执行P操作，若信号量大于零（有共享资源），则信号量减一，进程继续执行；若信号量为零，则进程等待。</p>
 <pre class="mermaid">    graph TB
     start(P 操作)--&gt;isSingleN{信号量}
     isSingleN---大于0--&gt; down(信号量减一)
     isSingleN---等于0--&gt; wait(等待)</pre>
<h4 id="V-操作"><a href="#V-操作" class="headerlink" title="V 操作"></a>V 操作</h4><p> 当进程执行 V 操作 ，若信号量大于零（有共享资源），则信号量加一；若信号量为零，则唤醒等待进程。</p>
 <pre class="mermaid">    graph TB
     start(V 操作)--&gt;isSingleN{信号量}
     isSingleN---大于0--&gt; down(信号量减一)
     isSingleN---等于0--&gt; wait(等待)</pre></li>
</ol>
<h3 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2. 内存管理"></a>2. 内存管理</h3><blockquote>
<p><strong>内存分配</strong>，<strong>地址映射</strong>，<strong>内存保护与共享</strong>，<strong>虚拟内存</strong>等</p>
</blockquote>
<p>内存的管理分为文件内存，和运行内存，对于进程管理比较重要的就是运存的管理了。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pica.zhimg.com/v2-4c9fcddd65b35e84c4c6783aaeee3826_1440w.jpg?source=172ae18b" alt="操作系统—内存管理"></p>
<h3 id="3-文件管理"><a href="#3-文件管理" class="headerlink" title="3. 文件管理"></a>3. 文件管理</h3><blockquote>
<p>文件存储空间的管理、目录管理、文件读写管理和保护等</p>
</blockquote>
<h3 id="4-设备管理"><a href="#4-设备管理" class="headerlink" title="4. 设备管理"></a>4. 设备管理</h3><blockquote>
<p>完成用户的 I/O 请求。为方便用户使用各种设备。并提高设备的利用率。</p>
<p>主要包括缓冲管理、设备分配、设备处理、虚拟设备等</p>
</blockquote>
<p>这是对外的扩展。比如一些键盘。鼠标的信号输入处理。除此之外。网络 I/O 。需要注意的是，文件 I/O 和这种I/O 是由区别的，文件 I/O，更多的偏向于软件层面，</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2186c6a7b85642089000f57d49a3e58c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p>
<blockquote>
<p>我们日常讨论的网络通信本质上就是网络I/O，通过网络I/O，我们可以和远程设备进行通信（数据交换）。由于网络I/O和正常的磁盘I/O在性能和访问方式上有较大的差异，所以针对磁盘I/O的读写方法也就无法适用于网络I/O身上，大部分操作系统针对网络I/O抽象除了一套特殊的接口—— <strong>网络Socket接口</strong> ，用于对网络I/O进行操作。当然，上面也说了，在Linux当中“一切皆文件”，为了统一概念，Socket在Linux当中也是通过文件描述符来进行描述的，只不过这个文件描述符描述的不是本地文件，而是远程设备对应的文件。<br>作者：Brucebat<br>链接：<a class="link" href="https://juejin.cn/post/7022249649511596063">https://juejin.cn/post/7022249649511596063<i class="fas fa-external-link-alt"></i></a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<p>对于 I/O 而言都是资源的访问，与接受，这两者的在我们使用的时候可能区别不大，但是对于计算机而言，处理的是不一样的信号量，网络 I/O 就像是外部数据的输入，文件 I/O 就如同内部资源的读写，网络 I/O 的另外一方就是通过网桥连接起来，使得信号能够交流.</p>
<p>Linux 的系统调用主要有以下:</p>
<table>
<thead>
<tr>
<th>Task</th>
<th>Commands</th>
</tr>
</thead>
<tbody><tr>
<td>进程控制</td>
<td>fork();exit();wait()</td>
</tr>
<tr>
<td>进程通信</td>
<td>pipe();shmget();mmap();</td>
</tr>
<tr>
<td>文件操作</td>
<td>open();read();write();</td>
</tr>
<tr>
<td>设备操作</td>
<td>ioctl();read();write();</td>
</tr>
<tr>
<td>信息维护</td>
<td>getpid();alarm();sleep();</td>
</tr>
<tr>
<td>安全</td>
<td>chmod();umask();chown();</td>
</tr>
</tbody></table>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而进入内核，有操作系统代为完成。</p>
<p>用户态只能调用受限指令。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img-blog.csdnimg.cn/319223950e3f4d6484f708d710d694da.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><h3 id="1-宏内核"><a href="#1-宏内核" class="headerlink" title="1. 宏内核"></a>1. 宏内核</h3><blockquote>
<p>宏内核是将操作系统功能作为一个紧密结合的整体放到类和。由于各个模块共享信息，因此有很高的性能。</p>
</blockquote>
<p>那么由于宏内核就是将所有的系统调用直接放在一层，那么这样的操作就避免了跨层的调用，因此效果很好，但是带来的问题就是耦合度明显很高，同时安全性也有待商榷。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic3.zhimg.com/80/v2-da9cab3e423cd0634c3752dce1a4ce82_720w.jpg" alt="img"></p>
<h3 id="2-微内核"><a href="#2-微内核" class="headerlink" title="2. 微内核"></a>2. 微内核</h3><p>由于操作系统不断复杂。因此将一部分操作系统功能移出内核(主要是上面描述的系统基本功能)。剩下保留一些核心的如时钟。中断的功能，微内核之间使用了消息通知机制。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic3.zhimg.com/80/v2-4aa2bb36f7461989770c6b14bf153776_720w.jpg" alt="img"></p>
<h3 id="总结-摘抄自知乎"><a href="#总结-摘抄自知乎" class="headerlink" title="总结(摘抄自知乎)"></a>总结(摘抄自<a class="link" href="https://zhuanlan.zhihu.com/p/394560786">知乎<i class="fas fa-external-link-alt"></i></a>)</h3><blockquote>
<p>宏内核其实就是把所有的功能都耦合起来，放在内核中，这样的优势就是性能极高，因为各个功能模块之间是可以直接调用的。缺点就是因为各个模块是相互关联，容易出现一错皆错的问题。</p>
</blockquote>
<blockquote>
<p>而微内核则恰恰相反，它为了降低耦合，内核中只会允许一些核心功能的存在，而其余所有功能都会被移出内核，变成一种特殊的用户进程——服务进程。其优点就是各个模块之间是独立的，不会相互影响，但其性能相比宏内核会大幅度下降。</p>
</blockquote>
<blockquote>
<p>混合内核则是结合上面二者的特点，它与微内核相似，只是会将一些功能模块又放回到内核中去，而不常用的功能模块还是放在用户层中。这样在微内核的基础上，又可以提高性能。</p>
</blockquote>
<p>内核的出现是为了解决系统调用复杂的耦合关系，也让各自的功能划分更加清晰。</p>
<h2 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h2><h3 id="1-外中断"><a href="#1-外中断" class="headerlink" title="1. 外中断"></a>1. 外中断</h3><p>由 CPU 执行指令之外的事件引起，如 I/O 完成终端，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。池外还有时钟中断，控制台中断等。</p>
<h3 id="2-异常"><a href="#2-异常" class="headerlink" title="2. 异常"></a>2. 异常</h3><p>由 CPU 执行指令的内部事件引起，如非法操作码，地址越界，算数溢出等。</p>
<h3 id="3-陷入"><a href="#3-陷入" class="headerlink" title="3. 陷入"></a>3. 陷入</h3><p>在用户程序中使用系统调用。</p>
]]></content>
      <tags>
        <tag>基础知识</tag>
        <tag>操作系统</tag>
        <tag>概览</tag>
      </tags>
  </entry>
</search>
