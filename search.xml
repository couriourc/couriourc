<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>操作系统知识点总结-发展与分类</title>
    <url>/2022/09/08/os-os-development/</url>
    <content><![CDATA[<h1 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h1><h2 id="手工操作阶段-纸带机"><a href="#手工操作阶段-纸带机" class="headerlink" title="手工操作阶段(纸带机)"></a>手工操作阶段(纸带机)</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://ts1.cn.mm.bing.net/th/id/R-C.6a9ef9f5e1fabc238012f843916fbd2c?rik=avHeSFBhXiM5YQ&riu=http://courseware.eduwest.com/courseware/0058/content/pictures/0001/image005.jpg&ehk=/o9LpDirUco4jDx2BFKbxoyO7fUG8C5rJBX7ySsxdFU=&risl=&pid=ImgRaw&r=0&sres=1&sresct=1" alt="R-S"></p>
<ul>
<li>用户独占主机</li>
<li>CPU 资源利用不充分</li>
<li>主要做偏向数理运算</li>
</ul>
<h2 id="批处理阶段"><a href="#批处理阶段" class="headerlink" title="批处理阶段"></a>批处理阶段</h2><p>批处理阶段可以认为是<strong>模块化</strong>的一个阶段,将指令进行打包存储(物理打包💦.</p>
<h3 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h3><p>主要使用磁带作为载体,引入了<strong>脱机输入/输出技术</strong>,并由监督程序复杂作业的输入输出.</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img-blog.csdnimg.cn/20190802142119391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE5MDE4Mjc3,size_16,color_FFFFFF,t_70" alt="单道批处理系统"></p>
<h3 id="主要优点"><a href="#主要优点" class="headerlink" title="主要优点"></a>主要优点</h3><ul>
<li><p>相比于手工接线,能避免这样的信息传输矛盾,资源利用率有所提升</p>
<p>  <img lazyload="" src="/images/loading.svg" data-src="https://img2018.cnblogs.com/blog/1358881/201905/1358881-20190531114741026-285335301.png" alt="img"></p>
</li>
</ul>
<blockquote>
<p>这里就相当于人工充当了 I/O 接口,和 DMA</p>
</blockquote>
<ul>
<li>代码/脚本 更便于保存(相对而言</li>
</ul>
<h3 id="主要缺点"><a href="#主要缺点" class="headerlink" title="主要缺点"></a>主要缺点</h3><ul>
<li><p>内存中仅能有一道程序运行,且 CPU 仍然有大量时间空闲等待 I/O 完成.</p>
</li>
<li><p>一次性消耗,如果出现 BUG ,很难修复,需要重新打孔☢</p>
</li>
</ul>
<h3 id="多道批处理系统-操作系统的正式诞生"><a href="#多道批处理系统-操作系统的正式诞生" class="headerlink" title="多道批处理系统(操作系统的正式诞生"></a>多道批处理系统(操作系统的正式诞生</h3><p>每次往计算机内存中输入多道程序,并引入了中断技术,有操作系统负责管理这些程序的并发运行.</p>
<p>过程和单道批处理系统差不多,只不过是可以向计算机<strong>内存</strong>中调入多道程序,让他们可以<strong>并发</strong>运行. — 基本特征</p>
<h4 id="主要优点-1"><a href="#主要优点-1" class="headerlink" title="主要优点"></a>主要优点</h4><ul>
<li>开始出现<strong>并发</strong>概念,<strong>共享</strong>计算机资源,CPU利用率大幅提升,让人工相对而言解放.</li>
</ul>
<h4 id="主要缺点-1"><a href="#主要缺点-1" class="headerlink" title="主要缺点"></a>主要缺点</h4><ul>
<li>用户响应时间长,没有人机交互功能(用户提交自己的作业之后只能等待计算机处理完成,无法介入控制自己的作业执行.</li>
</ul>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img-blog.csdnimg.cn/2019080215105153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE5MDE4Mjc3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img-blog.csdnimg.cn/20190802151520789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE5MDE4Mjc3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic4.zhimg.com/80/v2-792e1a2379bab12053cde690b4ddd9e7_720w.jpg" alt="img"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic3.zhimg.com/80/v2-3a0434c865fa2441632523d5aacd0e1e_720w.jpg" alt="img"></p>
<h2 id="分时操作系统-RR"><a href="#分时操作系统-RR" class="headerlink" title="分时操作系统(RR"></a>分时操作系统(RR</h2><p>计算机中 <strong>CPU</strong> 以时间片(<strong>10~100ms</strong>)为单位轮流为各个用户/作业服务,各个用户可以通过终端与计算机进行交互.</p>
<p>这个在后续的 CPU 调度算法中会继续讲到。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img-blog.csdnimg.cn/2019080215301587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE5MDE4Mjc3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="主要优点-2"><a href="#主要优点-2" class="headerlink" title="主要优点"></a>主要优点</h3><ul>
<li>用户请求就可以被响应，解决了人机交互问题，允许多个用户使用同一台电脑，并且用户对计算机操作是相互独立的。</li>
</ul>
<h3 id="主要缺点-2"><a href="#主要缺点-2" class="headerlink" title="主要缺点"></a>主要缺点</h3><ul>
<li>不能优先处理一些紧急任务，操作系统对各个<strong>用户/作业</strong>都是完全公平的，循环的为每一个 用户/作业 服务时间片，不区分任务的紧急性（同时这也是 RR 的缺点</li>
</ul>
<h2 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h2><p>为了解决分时操作系统不区分任务紧急性，导致任务饿死的情况，所以实时操作系统诞生。</p>
<p>利用这种调度策略，会更加有效的分配资源问题，让任务优先级可控。</p>
<h3 id="主要优点-3"><a href="#主要优点-3" class="headerlink" title="主要优点"></a>主要优点</h3><ul>
<li>响应紧急任务更加及时，紧急任务可以插队</li>
</ul>
<blockquote>
<p> 实时操作系统分为：</p>
<ul>
<li>硬实时系统（必须在绝对严格的规定时间内完成处理，如导弹控制系统，自动驾驶系统）</li>
<li>软实时系统（能偶尔违反时间规定，如12306火车退票系统，有时候数据并不是实时的）</li>
</ul>
</blockquote>
<h2 id="其他现代操作系统"><a href="#其他现代操作系统" class="headerlink" title="其他现代操作系统"></a>其他现代操作系统</h2><ul>
<li>网络操作熊：网络操作系统是伴随网络的发展出现的，对于网络资源的管理，比如网络邻居。</li>
<li>分布式操作系统：随着时代的发展，并发性和存储容量要求越来越高，需要有多个节点处理更多的数据，特点是分布式和并行性，各个节点平等的完成工作。</li>
<li>个人操作系统：面向于用户交互的操作系统，比如  <strong>Win10</strong>,<strong>Darwin</strong>,<strong>Ubuntu</strong>…</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><pre class="mermaid">graph LR
    Center(操作系统的发展)
    HumanHandle(手工操作阶段)
    BatchHandle(批处理阶段)
    SingleBatchHandle(单道批处理操作系统)
    MultiBatchHandle(多道批处理系统)
    RRCPUHandle(分时操作系统)
    FeedbackCPUHandle(实时操作系统)
    AnotherHandle(其他操作系统)

    Center--&gt;HumanHandle
    Center--&gt;BatchHandle--&gt;SingleBatchHandle
    BatchHandle--&gt;MultiBatchHandle
    Center--&gt;RRCPUHandle
    Center--&gt;FeedbackCPUHandle
    Center--&gt;AnotherHandle</pre>

]]></content>
      <tags>
        <tag>基础知识</tag>
        <tag>操作系统</tag>
        <tag>概览</tag>
        <tag>发展与分类</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统知识点总结-概览</title>
    <url>/2022/09/08/os-os-overview/</url>
    <content><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>操作系统个人认为更像是竞争问题，对于 CPU 的算力分配，和进程之间的分配问题，既要高效，又要健壮稳定。</p>
<pre class="mermaid">graph LR
    %% Graph 图，待处理解析展示
    Center((操作系统))
    
    Center --&gt; basePersonility(基本特征)
    basePersonility--&gt;并发
    basePersonility--&gt;共享
    basePersonility--&gt;虚拟
    basePersonility--&gt;异步
    
    Center --&gt; baseFunction(基本功能)
    baseFunction--&gt;进程管理
    baseFunction--&gt;内存管理
    baseFunction--&gt;文件管理
    baseFunction--&gt;设备管理

    Center--根据系统功能分类--&gt;sysInner(内核)
    sysInner--系统功能全在内核--&gt;marco(宏内核)
    sysInner--除核心功能之外的系统功能在内部--&gt;mirco(微内核) 
    sysInner--结合宏内核和微内核的特点--&gt;minixco(混合内核)
    
    Center--&gt;sysCall(系统调用)
    
    Center--&gt;interperter(中断分类)
    interperter--CPU执行指令之外的事件--&gt;外中断
    interperter--CPU执行内部事件引起的事件---&gt;异常
    interperter--在用户程序中使用的系统调用--&gt;陷入</pre>

<h2 id="操作系统的基本定义"><a href="#操作系统的基本定义" class="headerlink" title="操作系统的基本定义"></a>操作系统的基本定义</h2><blockquote>
<p>操作系统(Operating System,OS) 是指控制和管理整个计算机系统的硬件和软件资源,并合理地组织调度计算机和资源分配;提供给<strong>用户和其他软件方便的接口和环境</strong>;它是计算机系统中最基本的<strong>系统软件</strong>.</p>
</blockquote>
<h3 id="操作系统的角色"><a href="#操作系统的角色" class="headerlink" title="操作系统的角色"></a>操作系统的角色</h3><ul>
<li>操作系统是系统资源的<strong>管理者</strong></li>
<li>操作系统<strong>向上提供</strong>方便易用的服务</li>
<li>操作系统是<strong>最接近硬件</strong>的一层<strong>软件</strong></li>
</ul>
<h2 id="基础特征"><a href="#基础特征" class="headerlink" title="基础特征"></a>基础特征</h2><h3 id="1-并发"><a href="#1-并发" class="headerlink" title="1. 并发"></a>1. 并发</h3><blockquote>
<p>并发是指宏观上在一段时间内能同时运行多个程序，而并行则是指同一时刻能运行多个指令。</p>
<p>并行需要硬件支持，如多流水线，多核处理器或者分布式计算系统。</p>
<p>操作系统通过引入进程和线程，使得程序能够并发运行。</p>
</blockquote>
<p>并发运行并不是真真的同时完成多个任务，而是 <code>CPU</code> 的高速处理，使得各个任务之间来回进行，完成各个任务，而并行也就是我们实际业务希望解决的问题，但是对应带来的成本问题也就出现了。</p>
<!--TODO: 处理 Hexo 时序图问题--->

<pre class="mermaid">sequenceDiagram
    Note left of A: 进程A
    Note right of B: 进程B
    Note over A,B: CPU 在 AB 之间快速切换</pre>

<h3 id="2-共享"><a href="#2-共享" class="headerlink" title="2. 共享"></a>2. 共享</h3><blockquote>
<p>共享是指系统中的资源可以被多个并发进程共同使用。</p>
<p>主要有两种共享方式：<strong>互斥共享</strong>和<strong>同时共享</strong>。</p>
<p>互斥共享的资源被称为临界资源，特点是同时只能有一个占用，比如对于打印机这种外接设备，在同时只能允许一个进程访问，需要用同步机制实现互斥访问，有点类似队列结构（FIFO）。</p>
</blockquote>
<pre class="mermaid">sequenceDiagram
    title :按照顺序的去进入同一个进程
    participant AssetA
    participant AssetB</pre>



<h3 id="3-虚拟"><a href="#3-虚拟" class="headerlink" title="3. 虚拟"></a>3. 虚拟</h3><blockquote>
<p>虚拟技术把一个物理实体转换为多个逻辑实体。</p>
<p>主要有两种虚拟技术：时（时分复用技术）、空（空分复用技术）。</p>
<p>多个进程能在同一个处理器上并发执行也就利用了时分复用技术，让每一个进程轮流占用处理器，每次只执行一小个时间片，并快速切换。</p>
<p>虚拟内存则是使用了空分复用技术，他将物理内存抽象为地址空间，每一个进程都有各自的地址空间，地址空间的也被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有物理内存的页时，执行页面置换算法，将该页置换到内存中。</p>
<p>虚拟内存的关键问题：主要有调度问题、地址映射问题、替换问题、更新问题（要确保主存与辅存的一致性）</p>
</blockquote>
<p>个人认为，虚拟的好处在于可控，让每一步操作是出于可被控制可被调度的，也就使得可优化，更加稳定。</p>
<h3 id="4-异步"><a href="#4-异步" class="headerlink" title="4. 异步"></a>4. 异步</h3><blockquote>
<p>异步进程不是一次性排队完成，而是走走停停，每一步耗费的时间是不可知的</p>
</blockquote>
<p>异步和同步各自有不同的应用场景，不只是在操作系统上的概念，在各大编程语言上也有不同的信息。</p>
<h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><h3 id="1-进程管理"><a href="#1-进程管理" class="headerlink" title="1. 进程管理"></a>1. 进程管理</h3><blockquote>
<p><strong>进程控制</strong>，<strong>进程同步</strong>，<strong>进程通信</strong>，<strong>死锁处理</strong>，<strong>处理机调度</strong>等；</p>
</blockquote>
<ol>
<li><p>进程控制的主要功能是对系统中所有进程实施有效的管理，它具有创建新进程（<strong>fork</strong>），撤销已有进程，实现进程状态转换的功能；</p>
</li>
<li><p>进程同步，也就是异步环境下的一组并发进程因直接制约而互相发送消息，进行互相合作，互相等待，使得各个进程按一定的速度执行的过程，成为进程间的同步，具有同步关系的一组并发进程称为合作进程，合作进程互相发送的信号成为消息或事件，对这样的消息或者事件给一个名称，则我们可用 wait(消息名)表示经常等待合作进程发来的消息，而用过程 signal(消息名)表示像合作进程发送消息。</p>
<p>进程同时处理同一串数据，会造成不确定性，有多个进程同时对一个文件进行读写，那么读文件的进程无法确定督导的数据是它本来想要的数据（老数据），还是被修改的数据（新数据 <code>modified data</code>），除此之外，当先读后写的时候，由于缓冲区没有写入数据，读进程无数据可读，就进入了阻塞态。</p>
<p>这种两个或多个进程读写某些共享数据，而最后的结果却决于进行的精准时序，称为数据竞争，而这种多个程序可以并发执行，但是由于系统资源有限，程序的执行不是一贯到底的，而是以不可预知的速度推进的，这也就是之前说的<strong>异步性</strong>。</p>
<p>这种受到访问顺序限制的的数据是没有意义的（对于程序运行不能有二义性，也就是某一个状态是确定的），所以为了能够使得进程有一定的顺序来访问数据，从而引入了同步的概念。</p>
<p>对于资源是如此，对于数据库操作同样也是如此。</p>
<p>而之前所说的信号，下述便是对于用信号量实现进程同步的步骤，主要分为 PV 两大操作。</p>
<p><strong>信号量</strong>的作用就是控制多进程共享资源的访问（资源有限并且不共享），其本质是任一时刻只能有一个进程访问临界区（代码）数据更新的代码。</p>
<h4 id="PV操作"><a href="#PV操作" class="headerlink" title="PV操作"></a>PV操作</h4><p>PV操作即是针对信号量进行的相应操作，PV操作由P操作原语和V操作原语组成（原语是不可中断的过程）。</p>
<h4 id="P-操作"><a href="#P-操作" class="headerlink" title="P 操作"></a>P 操作</h4><p>当进程执行P操作，若信号量大于零（有共享资源），则信号量减一，进程继续执行；若信号量为零，则进程等待。</p>
 <pre class="mermaid">    graph TB
     start(P 操作)--&gt;isSingleN{信号量}
     isSingleN---大于0--&gt; down(信号量减一)
     isSingleN---等于0--&gt; wait(等待)</pre>

<h4 id="V-操作"><a href="#V-操作" class="headerlink" title="V 操作"></a>V 操作</h4><p>当进程执行 V 操作 ，若信号量大于零（有共享资源），则信号量加一；若信号量为零，则唤醒等待进程。</p>
 <pre class="mermaid">    graph TB
     start(V 操作)--&gt;isSingleN{信号量}
     isSingleN---大于0--&gt; down(信号量减一)
     isSingleN---等于0--&gt; wait(等待)</pre></li>
</ol>
<h3 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2. 内存管理"></a>2. 内存管理</h3><blockquote>
<p><strong>内存分配</strong>，<strong>地址映射</strong>，<strong>内存保护与共享</strong>，<strong>虚拟内存</strong>等</p>
</blockquote>
<p>内存的管理分为文件内存，和运行内存，对于进程管理比较重要的就是运存的管理了。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pica.zhimg.com/v2-4c9fcddd65b35e84c4c6783aaeee3826_1440w.jpg?source=172ae18b" alt="操作系统—内存管理"></p>
<h3 id="3-文件管理"><a href="#3-文件管理" class="headerlink" title="3. 文件管理"></a>3. 文件管理</h3><blockquote>
<p>文件存储空间的管理、目录管理、文件读写管理和保护等</p>
</blockquote>
<h3 id="4-设备管理"><a href="#4-设备管理" class="headerlink" title="4. 设备管理"></a>4. 设备管理</h3><blockquote>
<p>完成用户的 I/O 请求。为方便用户使用各种设备。并提高设备的利用率。</p>
<p>主要包括缓冲管理、设备分配、设备处理、虚拟设备等</p>
</blockquote>
<p>这是对外的扩展。比如一些键盘。鼠标的信号输入处理。除此之外。网络 I/O 。需要注意的是，文件 I/O 和这种I/O 是由区别的，文件 I/O，更多的偏向于软件层面，</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2186c6a7b85642089000f57d49a3e58c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p>
<blockquote>
<p>我们日常讨论的网络通信本质上就是网络I/O，通过网络I/O，我们可以和远程设备进行通信（数据交换）。由于网络I/O和正常的磁盘I/O在性能和访问方式上有较大的差异，所以针对磁盘I/O的读写方法也就无法适用于网络I/O身上，大部分操作系统针对网络I/O抽象除了一套特殊的接口—— <strong>网络Socket接口</strong> ，用于对网络I/O进行操作。当然，上面也说了，在Linux当中“一切皆文件”，为了统一概念，Socket在Linux当中也是通过文件描述符来进行描述的，只不过这个文件描述符描述的不是本地文件，而是远程设备对应的文件。<br>作者：Brucebat<br>链接：<a class="link" href="https://juejin.cn/post/7022249649511596063">https://juejin.cn/post/7022249649511596063<i class="fas fa-external-link-alt"></i></a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<p>对于 I/O 而言都是资源的访问，与接受，这两者的在我们使用的时候可能区别不大，但是对于计算机而言，处理的是不一样的信号量，网络 I/O 就像是外部数据的输入，文件 I/O 就如同内部资源的读写，网络 I/O 的另外一方就是通过网桥连接起来，使得信号能够交流.</p>
<p>Linux 的系统调用主要有以下:</p>
<table>
<thead>
<tr>
<th>Task</th>
<th>Commands</th>
</tr>
</thead>
<tbody><tr>
<td>进程控制</td>
<td>fork();exit();wait()</td>
</tr>
<tr>
<td>进程通信</td>
<td>pipe();shmget();mmap();</td>
</tr>
<tr>
<td>文件操作</td>
<td>open();read();write();</td>
</tr>
<tr>
<td>设备操作</td>
<td>ioctl();read();write();</td>
</tr>
<tr>
<td>信息维护</td>
<td>getpid();alarm();sleep();</td>
</tr>
<tr>
<td>安全</td>
<td>chmod();umask();chown();</td>
</tr>
</tbody></table>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而进入内核，有操作系统代为完成。</p>
<p>用户态只能调用受限指令。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img-blog.csdnimg.cn/319223950e3f4d6484f708d710d694da.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><h3 id="1-宏内核"><a href="#1-宏内核" class="headerlink" title="1. 宏内核"></a>1. 宏内核</h3><blockquote>
<p>宏内核是将操作系统功能作为一个紧密结合的整体放到类和。由于各个模块共享信息，因此有很高的性能。</p>
</blockquote>
<p>那么由于宏内核就是将所有的系统调用直接放在一层，那么这样的操作就避免了跨层的调用，因此效果很好，但是带来的问题就是耦合度明显很高，同时安全性也有待商榷。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic3.zhimg.com/80/v2-da9cab3e423cd0634c3752dce1a4ce82_720w.jpg" alt="img"></p>
<h3 id="2-微内核"><a href="#2-微内核" class="headerlink" title="2. 微内核"></a>2. 微内核</h3><p>由于操作系统不断复杂。因此将一部分操作系统功能移出内核(主要是上面描述的系统基本功能)。剩下保留一些核心的如时钟。中断的功能，微内核之间使用了消息通知机制。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic3.zhimg.com/80/v2-4aa2bb36f7461989770c6b14bf153776_720w.jpg" alt="img"></p>
<h3 id="总结-摘抄自知乎"><a href="#总结-摘抄自知乎" class="headerlink" title="总结(摘抄自知乎)"></a>总结(摘抄自<a class="link" href="https://zhuanlan.zhihu.com/p/394560786">知乎<i class="fas fa-external-link-alt"></i></a>)</h3><blockquote>
<p>宏内核其实就是把所有的功能都耦合起来，放在内核中，这样的优势就是性能极高，因为各个功能模块之间是可以直接调用的。缺点就是因为各个模块是相互关联，容易出现一错皆错的问题。</p>
</blockquote>
<blockquote>
<p>而微内核则恰恰相反，它为了降低耦合，内核中只会允许一些核心功能的存在，而其余所有功能都会被移出内核，变成一种特殊的用户进程——服务进程。其优点就是各个模块之间是独立的，不会相互影响，但其性能相比宏内核会大幅度下降。</p>
</blockquote>
<blockquote>
<p>混合内核则是结合上面二者的特点，它与微内核相似，只是会将一些功能模块又放回到内核中去，而不常用的功能模块还是放在用户层中。这样在微内核的基础上，又可以提高性能。</p>
</blockquote>
<p>内核的出现是为了解决系统调用复杂的耦合关系，也让各自的功能划分更加清晰。</p>
<h2 id="操作系统向上提供方便易用的服务"><a href="#操作系统向上提供方便易用的服务" class="headerlink" title="操作系统向上提供方便易用的服务"></a>操作系统向上提供方便易用的服务</h2><h3 id="命令接口"><a href="#命令接口" class="headerlink" title="命令接口"></a>命令接口</h3><ul>
<li>联机命令接口(交互式命令接口)-&gt;基本命令行(CLI)</li>
<li>脱机命令接口(批处理命令接口)-&gt;脚本(bat ,sh)</li>
<li>程序接口(广义指令)-&gt;GUI</li>
</ul>
<blockquote>
<p>可以再程序中进行系统调用来使用程序接口,普通用户不能直接使用程序接口,只能通过程序代码间接使用.</p>
</blockquote>
<h2 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h2><h3 id="1-外中断"><a href="#1-外中断" class="headerlink" title="1. 外中断"></a>1. 外中断</h3><p>由 CPU 执行指令之外的事件引起，如 I/O 完成终端，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。池外还有时钟中断，控制台中断等。</p>
<h3 id="2-异常"><a href="#2-异常" class="headerlink" title="2. 异常"></a>2. 异常</h3><p>由 CPU 执行指令的内部事件引起，如非法操作码，地址越界，算数溢出等。</p>
<h3 id="3-陷入"><a href="#3-陷入" class="headerlink" title="3. 陷入"></a>3. 陷入</h3><p>在用户程序中使用系统调用。</p>
]]></content>
      <tags>
        <tag>基础知识</tag>
        <tag>操作系统</tag>
        <tag>概览</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统知识点总结-进程调度算法</title>
    <url>/2022/09/09/os-os-process-sheduler/</url>
    <content><![CDATA[<h1 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h1><p>不同环境的调度算法目标不同,因此需要针对不同环境来讨论调度算法.</p>
<h2 id="调度的概念"><a href="#调度的概念" class="headerlink" title="调度的概念"></a>调度的概念</h2><blockquote>
<p>在处理机调度是对处理机进行分配，即从就绪队列中按照一定的算法选择一个进程并将处理机给它运行，以实现进程并发地运行。</p>
</blockquote>
<p>这样说起来可能有点绕，其实就是 CPU 这些处理器，按照一定策略执行某个进程。</p>
<p>处理机调度是多道程序操作系统的基础，是操作系统设计的核心问题。</p>
<h2 id="调度的层次"><a href="#调度的层次" class="headerlink" title="调度的层次"></a>调度的层次</h2><h3 id="作业调度（高级调度）"><a href="#作业调度（高级调度）" class="headerlink" title="作业调度（高级调度）"></a>作业调度（高级调度）</h3><blockquote>
<p>按照一定原则从外存上处于后备（待开始）队列的作业选择一个或多个作业，给予必要的资源，并建立相应的<strong>进程块</strong>（<strong>PCB</strong>）,以使他获得竞争处理及资源的权力。</p>
</blockquote>
<p>作业调度是外存和内存之间的调度，每个作业只调用一次，调出一次，作业调度时建立。</p>
<p>也就是进程的创建过程。</p>
<h3 id="内存调度（中级调度）"><a href="#内存调度（中级调度）" class="headerlink" title="内存调度（中级调度）"></a>内存调度（中级调度）</h3><blockquote>
<p>可以将暂时不能运行的进程调至外存等待，这些进程会进入“<strong>挂起</strong>”状态，其 <strong>PCB</strong> 仍然常驻在内存，将放入到挂起队列中，其目的是提高内存利用率和系统吞吐量。</p>
</blockquote>
<p>通过中级调度来决定哪个处于挂起状态的进程重新调入内存中。</p>
<h3 id="进程调度（低级调度）"><a href="#进程调度（低级调度）" class="headerlink" title="进程调度（低级调度）"></a>进程调度（低级调度）</h3><blockquote>
<p>按照某种方法和策略从就绪队列中选择一个进程，将处理及分配。</p>
</blockquote>
<p>进程调度是操作系统<strong>最基本的一种调度，其频率很高</strong>，一般几十毫秒（一个时间片</p>
<table>
<thead>
<tr>
<th>调度类型</th>
<th>调度位置</th>
<th>进程状态变化</th>
</tr>
</thead>
<tbody><tr>
<td>作业调度（高级调度）</td>
<td>外存–&gt;内存（面向作业）</td>
<td>无–&gt;创建态–&gt;就绪态</td>
</tr>
<tr>
<td>内存调度（中级调度）</td>
<td>外存–&gt;内存（面向进程）</td>
<td>挂起–&gt;就绪态（阻塞挂起–&gt;阻塞态）</td>
</tr>
<tr>
<td>进程调度（低级调度）</td>
<td>内存–&gt;CPU</td>
<td>就绪态–&gt;挂起态</td>
</tr>
</tbody></table>
<h2 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h2><p>批处理系统没有太多的用户操作,该系统中,调度算法目标是保证吞吐量和周转时间(从提交到终止的时间).</p>
<h3 id="1-1-先来先服务-first-come-fist-serverd-FCFS"><a href="#1-1-先来先服务-first-come-fist-serverd-FCFS" class="headerlink" title="1.1 先来先服务(first-come-fist-serverd FCFS)"></a><span id="FCFS">1.1 先来先服务(first-come-fist-serverd FCFS)</span></h3><p>非抢占式的调度算法,按照顺序进行调度.</p>
<p>有利于长作业,但不利于短作业,因为短作业必须一直等待前面的长作业执行完毕才能执行,而长作业又需要执行很长的时间,造成了短作业等待的时间过长.</p>
<p>最优状态,耗时短的作业先被执行:</p>
<pre class="mermaid">sequenceDiagram
    participant work_short_time_1
    participant work_short_time_2
    participant work_long_time_1
    participant worl_long_time_2</pre>

<p>最不利状态,耗时的作业一直占用 <code>CPU</code>,使得最短作业始终无法完成:</p>
<pre class="mermaid">sequenceDiagram
participant work_long_time_1
participant worl_long_time_2
participant work_short_time_1
participant work_short_time_2</pre>



<h3 id="1-2-短作业优先-shortest-job-fist-SJF"><a href="#1-2-短作业优先-shortest-job-fist-SJF" class="headerlink" title="1.2 短作业优先(shortest-job-fist SJF)"></a>1.2 短作业优先(shortest-job-fist SJF)</h3><p>非抢占式的掉段算法,按估计运行时间最短的顺序进行调度.</p>
<p>长作业有可能会饿死,处于一直等待短作业执行完毕的状态.因为如果一直有短作业到来,那么长作业永远得不到调度.</p>
<p>比较优的状态,耗时短的任务总量少于长任务,这样让作业更多的占比完成:</p>
<pre class="mermaid">sequenceDiagram
participant work_short_time
participant work_short_time
participant work_long_time</pre>

<p>不利状态,耗时短的任务总量远大于长任务,那么这样饿死的就是相对较短的长任务了🎃:</p>
<pre class="mermaid">sequenceDiagram
    participant work_short_time
    participant work_short_time_2
    participant .....一堆短任务
    participant work_long_time_1
    participant work_long_time_2</pre>



<h3 id="1-3-最短剩余时间优先-shortest-remaining-time-time-next-SRTN"><a href="#1-3-最短剩余时间优先-shortest-remaining-time-time-next-SRTN" class="headerlink" title="1.3 最短剩余时间优先(shortest remaining time time next SRTN)"></a>1.3 最短剩余时间优先(shortest remaining time time next SRTN)</h3><p>最短作业优先的抢占式版本,按剩余运行时间的顺序调度,当一个新作也到达时,其整个运行时间与当前进程的剩余时间作比较,如果新的进程需要的时间更少,则挂起当前进程,运行新的进程,否则新的进程等待.</p>
<h2 id="2-交互式系统"><a href="#2-交互式系统" class="headerlink" title="2.交互式系统"></a>2.交互式系统</h2><pre class="mermaid">graph LR
Center(调度算法)
RoundRobin(时间片轮转算法)
Priority(优先级算法)
Feedback(多级反馈队列调度算法)
Center--&gt;RoundRobin
Center--&gt;Priority
Center--&gt;Feedback</pre>



<blockquote>
<p>交互式系统又大量的用户交互操作,在该系统中调度算法的目标是快速地进行响应.</p>
</blockquote>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="2-1-时间片轮转"><a href="#2-1-时间片轮转" class="headerlink" title="2.1 时间片轮转"></a>2.1 时间片轮转</h3><blockquote>
<p>将所有的就绪进程按照<a href="#FCFS">FCFS</a> 的原则排成一个队列,每次调度时,把<code>CPU</code>时间分配给对首进程,该进程可以执行一个时间片.当时间片用完时,由计时器发出时钟中断,调度程序便停止该进程的执行,并将它送往就绪队列的末尾,同时继续把CPU时间分配给队列的末尾,同时继续把CPU时间分配给队首的进程.</p>
<p>时间片轮转算法的效率和时间片的大小很有关系:</p>
<ul>
<li>因为进程切换都要保存进程的信息并且载入新进程的信息,若时间片太小,会导致进程切换得太频繁,在进程切换上就会花很多时间.</li>
<li>而如果时间片过长,那么实时性就不能得到保证</li>
</ul>
</blockquote>
<p>该算法中,将一个较小时间单元定义为时间量或时间片,时间片得大小通常为 <strong>10-100ms</strong> .就绪队列作为循环队列,<code>CPU</code> 调度程序循环真个就绪队列,为每个进程分配不超过一个时间片的 <code>CPU</code>.</p>
<p>为了实现 RR 调度,先将就绪队列视为进程的 <code>FIFO</code> 队列,新进程添加到就绪对列的尾部,<code>CPU</code> 调度程序从就绪对列中选择第一个进程,将定时器设置在一个时间片后中断,最后分派这个进程.</p>
<p>之后将可能出现两种情况..经常可能只需要少于时间片的 <code>CPU</code> 的任务执行.对于这种情况,进程本身会自动释放 <code>CPU</code>,调度程序将接着处理就绪对列的下一个进程.否则,如果当前运行进程的 <code>CPU</code>执行大于一个时间片,那么定时器肯定会中断(超时),进而中断操作系统.然后,进行上下文切换,再将进程加到就绪对列的尾部,接着 <code>CPU</code> 调度程序会选择就绪队列的下一个进程.</p>
<blockquote>
<p>前面提到过,一个进程块保留有进程信息,在中断之后,可以用来恢复上下文环境.</p>
</blockquote>
<p>不过,采用 RR 策略的平均等待时间通常较长,如果有如下状况的几组任务,他们在时间 0 到达.</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>执行时间</th>
</tr>
</thead>
<tbody><tr>
<td>P<del>1</del></td>
<td>24</td>
</tr>
<tr>
<td>P<del>2</del></td>
<td>3</td>
</tr>
<tr>
<td>P<del>3</del></td>
<td>3</td>
</tr>
</tbody></table>
<p>如果使用 <strong>4ms</strong> 的(CPU)时间片,那么 <code>Task_A</code> 会执行最初的 <code>4ms</code>,由于它还需要 <code>20ms</code>,所以在第一个时间片之后,他会被抢占,而 <code>CPU</code> 就交给对列中的下一个进程(P<del>2</del>),由于 P<del>2</del> 不需要一个时间片,所以其他时间片用完之前就会退出.<code>CPU</code> 又交给了进程 P<del>1</del> 以便继续执行</p>
<pre class="mermaid">sequenceDiagram
    participant timer
    participant P1 as P1(24)
    participant P2 as P2(3) 
    participant P3 as P3(3)
    timer -&gt;&gt; P1: 时间片
    
    loop 完成 4ms 的任务
        P1 --&gt; P1: 
    end 
    
    P1 -&gt;&gt; P2: 时间片
    
    loop 完成 4ms 的任务
        P2 --&gt;&gt; P2: 时间片大于3提前退出
    end
    
    P2-&gt;&gt;P3: 时间片
    loop 完成 4ms 的任务
        P3--&gt;P3: 时间片大于3提前退出
    end
    
    P3-&gt;P1: 时间片
    loop 队列已空,持续完成该任务
        P1 --&gt; P1: 
    end</pre>

<p><img lazyload="" src="/images/loading.svg" data-src="http://c.biancheng.net/uploads/allimg/181106/2-1Q10615295H44.gif" alt="时间片轮转调度结果"></p>
<p>计算这个调度的平均等待时间,P<del>1</del>等待了 <mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="35.131ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 15528 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path></g><g data-mml-node="mo" transform="translate(1222.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(2222.4,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><g data-mml-node="mo" transform="translate(2722.4,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(3111.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">从</text></g><g data-mml-node="mi" transform="translate(4111.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">第</text></g><g data-mml-node="mn" transform="translate(5111.4,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><g data-mml-node="mi" transform="translate(5611.4,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(6489.4,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(6958.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">就</text></g><g data-mml-node="mi" transform="translate(7958.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">开</text></g><g data-mml-node="mi" transform="translate(8958.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">始</text></g><g data-mml-node="mi" transform="translate(9958.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">等</text></g><g data-mml-node="mi" transform="translate(10958.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">待</text></g><g data-mml-node="mo" transform="translate(11958.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(12625.2,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(13681,0)"><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z"></path></g><g data-mml-node="mi" transform="translate(14181,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(15059,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g></g></g></svg></mjx-container>,P<del>2</del>等待了 <strong>4ms</strong> ,而 P<del>3</del> 等待了 <strong>7ms</strong> ,因此平均等待时间为 <mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="14.612ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 6458.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z" transform="translate(500,0)"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1000,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path></g></g><g data-mml-node="mn" transform="translate(1500,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><g data-mml-node="mo" transform="translate(2277.8,0)"><path data-c="2248" d="M55 319Q55 360 72 393T114 444T163 472T205 482Q207 482 213 482T223 483Q262 483 296 468T393 413L443 381Q502 346 553 346Q609 346 649 375T694 454Q694 465 698 474T708 483Q722 483 722 452Q722 386 675 338T555 289Q514 289 468 310T388 357T308 404T224 426Q164 426 125 393T83 318Q81 289 69 289Q55 289 55 319ZM55 85Q55 126 72 159T114 210T163 238T205 248Q207 248 213 248T223 249Q262 249 296 234T393 179L443 147Q502 112 553 112Q609 112 649 141T694 220Q694 249 708 249T722 217Q722 153 675 104T555 55Q514 55 468 76T388 123T308 170T224 192Q164 192 125 159T83 84Q80 55 69 55Q55 55 55 85Z"></path></g><g data-mml-node="mn" transform="translate(3333.6,0)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500,0)"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(778,0)"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(1278,0)"></path></g><g data-mml-node="mi" transform="translate(5111.6,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(5989.6,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g></g></g></svg></mjx-container> .</p>
<p>在 RR 调度算法中,没有进程被连续分配超过一个时间片的 CPU(除非他是对列中唯一可运行的进程).如果进程的 <code>CPU</code> 执行进程超过一个时间片,那么该进程会被抢占,并被放回到就绪对列,因此,RR 调度算法是抢占的.</p>
<h3 id="2-2-优先级调度"><a href="#2-2-优先级调度" class="headerlink" title="2.2 优先级调度"></a>2.2 优先级调度</h3><p>为每一个进程,按优先级进行调度.</p>
<p>为了防止低优先级永远等不到调度,可以随着时间的推移增加等待进程的优先级.</p>
<p>对于优先级调度,进一步可以被划分为非抢占式优先级调度算法和抢占式优先级.</p>
<h3 id="2-3-多级反馈队列"><a href="#2-3-多级反馈队列" class="headerlink" title="2.3 多级反馈队列"></a>2.3 多级反馈队列</h3><p>一个进程需要 100 个时间片,如果采用<code>RR</code> ,那么需要交换 100 次.</p>
<p>多级队列是为这种需要连续执行多个时间片的进程考虑的,它设置了多个队列,每个队列时间片大小都不同,列如 1,2,4,8,..…进程在第一个队列没执行完,就会被移到下一个队列.这种方式下,之前的进程只需要交换 7 次.</p>
<p>每个队列的优先权也不同,最上面的优先权最高.因此只有上一个队列没有进程在排队,才能调度当前队列上的进程.</p>
<p>可以将这种算法看作是 <code>RR </code>和优先级调度算法的结合.</p>
<p>对于优先级最低的队列来说,里面遵循的是 <code>RR</code> .也就是说,位于队列中有  M 个作业,他们的运行时间是通过队列所设定的时间片来确定的;对于其他队列,遵循的是<code>FIFS</code>,每一个进程分配一定的时间片,若时间片进程未结束,则进入下一优先级队列的末尾.</p>
<p>各个队列的时间片是随着优先级的增加而减少的,也就是说,优先级越高的队列中他的时间片越短,同时,为了便于那些超大作业的完成,最后一个队列的时间片一般不大</p>
<h2 id="上下文及切换地址"><a href="#上下文及切换地址" class="headerlink" title="上下文及切换地址"></a>上下文及切换地址</h2><pre class="mermaid">graph BT

subgraph 线程的内容
    pc(程序计数器)
    registry(寄存器)
    heap(堆栈)
    status(状态)
end

subgraph 进程的内容
    addreaddSpace(地址空间)
    globalVar(全局变量)
    assets("打开文件")
end

classDef important fill:#b03853,color: #eeee;
class addreaddSpace,pc,registry,heap important;</pre>

<blockquote>
<p>标红部分 是进程/线程切换时需要恢复的上下文</p>
</blockquote>
<p>进程切换导致的地址空间代价巨大：</p>
<ul>
<li><p>保存/恢复页表寄存器</p>
</li>
<li><p><code>TLB </code>全部失效<img lazyload="" src="/images/loading.svg" data-src="https://pic4.zhimg.com/80/v2-70f03a91b02fe51cced8cb57fa30d84b_720w.jpg" alt="img"></p>
</li>
<li><p><code>Cache </code>全部失效，有可能需要 <code>Cache </code>回写恢复</p>
</li>
<li><p>新进程运行初期可能缺页不高，需要 <code>I/O</code> 操作</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>基础知识</tag>
        <tag>操作系统</tag>
        <tag>进程管理</tag>
        <tag>调度算法</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统知识点总结-进程同步</title>
    <url>/2022/09/12/os-os-process-sync/</url>
    <content><![CDATA[<h1 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h1><h2 id="进程同步的概念"><a href="#进程同步的概念" class="headerlink" title="进程同步的概念"></a>进程同步的概念</h2><h3 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h3><p>临界资源指一个时间段内只允许一个进程使用的资源（互斥资源）。</p>
<blockquote>
<p>例如物理设备，内存缓冲区等都是临界资源</p>
</blockquote>
<p>在每一个进程中，访问临界资源的那部分指令被称为临界区，对临界区的访问可以分为四个阶段：</p>
<pre class="mermaid">sequenceDiagram

participant  entry as 进入区域 
participant  crisis as 临界区 
participant exit as 退出区
participant remainder as 剩余区

loop always
    entry  --&gt; remainder: 
end</pre>

<ul>
<li><strong>进入区</strong>：检查是否可以进入临界区，若可以进入，则设置正在访问临界资源的标志，以阻止其他进程进入临界区。</li>
<li><strong>临界区</strong>（<strong>临界段</strong>）：进程中访问临界区的一段代码。</li>
<li><strong>退出区</strong>：将正在访问临界资源的标志解除。</li>
<li><strong>剩余区</strong>：代码中其他部分。</li>
</ul>
<p><span style="color:red;">🧡进入区和退出区负责实现互斥</span></p>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p><strong>同步</strong>：亦称为<strong>直接制约关系</strong>，他是指完成某种任务而建立的<strong>两个或多个</strong>进程，这些进程因为需要在某些位置上协调他们的工作次序而产生的制约关系。进程间的<strong>直接制约关系</strong>就是因为他们的相互合作。</p>
<h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><p>对临界资源的访问，<strong>必须</strong>互斥的进行。</p>
<p>互斥：亦称<strong>间接制约关系</strong>，进程互斥指当一个进程访问临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束。释放该资源之后，另一个进程才能去访问临界资源。</p>
<h3 id="互斥的原则"><a href="#互斥的原则" class="headerlink" title="互斥的原则"></a>互斥的原则</h3><ul>
<li>空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程，立即进入临界区。</li>
<li>忙则等待：若已有进程进入临界区时，其他试图进入临界区的进程必须等待。</li>
<li>有限等待：对请求访问的进程，因保证能在有限时间内进入临界区（保证不饥饿）</li>
<li>让权等待：当进程不能进入临界区时，应立刻释放处理机，防止进程忙等待。</li>
</ul>
<blockquote>
<p>一句话，就是 <strong>（处理机or资源）物尽其用</strong>，**(能力or资源)不够就等**</p>
</blockquote>
<h2 id="临界区互斥的实现"><a href="#临界区互斥的实现" class="headerlink" title="临界区互斥的实现"></a>临界区互斥的实现</h2><h3 id="单标志法"><a href="#单标志法" class="headerlink" title="单标志法"></a>单标志法</h3><p>一个进程在访问完临界区后会把临界区资源的权限交给另一个进程，也就是说每个进程进入临界区的权限只能由前辈（另一个程序赋予）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> turn = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">p0</span> <span class="hljs-params">()</span></span>{<br>    <span class="hljs-keyword">while</span> (turn != <span class="hljs-number">0</span>);<br>    critical section;<br>    turn = <span class="hljs-number">1</span>;<br>    remainder section;<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">p1</span><span class="hljs-params">()</span></span>{<br>    <span class="hljs-keyword">while</span>(turn != <span class="hljs-number">1</span>);<br>    critical section;<br>    turn = <span class="hljs-number">0</span>;<br>    remainder section;<br>}<br><br></code></pre></td></tr></table></figure>

<p>就如同单锁一样，自己在用的时候，其他进程就不能用，自己用完了，立马就把占有权给人家。</p>
<blockquote>
<p>好比如：现在是桌上只有一双筷子，有A跟B两个人，一开始先把筷子给A，A吃完后直接就把筷子洗干净给B了，然后说你吃完再把筷子洗干净给我，结果B无语了，他也没说要用筷子吃东西，然后A就是说不管，你必须吃完过后再把筷子给我，结果A自己又想吃的时候结果没有筷子用，因为筷子还在B那里呢，B还在纳闷A怕不是有什么大病。<br>    该比喻来自 CSDN「叫我蘑菇先生」的<a class="link" href="https://blog.csdn.net/weixin_43305485/article/details/120754983">原创文章<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<h3 id="双标志先检查法"><a href="#双标志先检查法" class="headerlink" title="双标志先检查法"></a>双标志先检查法</h3><p>设置一个数组，相应元素标识进程访问的资源的意愿。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> flag[] = {<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>};<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">p0</span><span class="hljs-params">()</span></span>{<br>  <span class="hljs-comment">// 或者 用 if (flag[1]) return ;</span><br>  <span class="hljs-comment">//大抵就是，如果 1 占有的时候，就不继续执行下面的，</span><br>    <span class="hljs-keyword">while</span> (flag[<span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">// 表明自己在占有</span><br>    flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 拿到临界区资源</span><br>    critical section;<br>    <span class="hljs-comment">// 自己用好了</span><br>    flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 退回资源</span><br>    remaider section;<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">p1</span><span class="hljs-params">()</span></span>{<br>    <span class="hljs-keyword">while</span>(flag[<span class="hljs-number">0</span>]);<br>    flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 拿到临界区资源</span><br>    critical section;<br>    <span class="hljs-comment">// 自己用好了</span><br>    falg[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>  <span class="hljs-comment">// 退回资源</span><br>    remaider section;<br>}<br></code></pre></td></tr></table></figure>

<p>相当于时各自等待别人表态，如果别人不用了，自己再用；可能<strong>违背忙则等待</strong>的原则。</p>
<blockquote>
<p>好比如：现在同样是桌上只有一双筷子，有A跟B两个人，但是现在这两个人会察言观色了，会先看对方会不会想要先用筷子，然后再判断下一步是使用筷子还是接着等待。一开始，两个人都不说自己想不想用筷子，就等对方先表态，毕竟要多谦让，最后彼此看这么久都不说话，估计就是不想用了，然后彼此都默认对方不想用筷子。这个时候就会出现问题了，两个人都默认彼此不想用筷子，然后自己就下意识去拿筷子，结果刚好对方也想用，这就尴尬了，那最后是谁用呢，这个时候就会出现资源被同时访问的问题。</p>
<p>该比喻来自 CSDN「叫我蘑菇先生」的<a class="link" href="https://blog.csdn.net/weixin_43305485/article/details/120754983">原创文章<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<hr>
<h3 id="双标志后检查法"><a href="#双标志后检查法" class="headerlink" title="双标志后检查法"></a>双标志后检查法</h3><p>相比于双标志先检查法，此算法先修改自己的一员，再进行检查。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> flag[] = { <span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>};<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-type">bool</span> &amp;which)</span></span>{<br>    <span class="hljs-keyword">while</span>(which);<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">p0</span><span class="hljs-params">()</span></span>{<br>    flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-built_in">wait</span>(flag[<span class="hljs-number">1</span>]);<br>    critical section;<br>  flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;<br>    remainder section;<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">p1</span><span class="hljs-params">()</span></span>{<br>    flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-built_in">wait</span>(flag[<span class="hljs-number">0</span>]);<br>    critical section;<br>  flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>    remainder section;<br>}<br></code></pre></td></tr></table></figure>

<p>这一算法解决了“忙则等待”的问题，但是若两个进程同时标记为true，又会相互等待造成<strong>饥饿</strong>，违背了“<strong>空闲让进</strong>”和“<strong>有限等待</strong>”原则。</p>
<blockquote>
<p>好比如：现在还是桌上只有一双筷子，但是现在就不是A跟B了，换成孔融1号和孔融2号，为什么给他们这样取名字呢，后面就知道啦！现在这两个人呢，在想用筷子的时候都会先说出来表明自己的态度，然后再看对方会不会想要先用筷子，然后再判断下一步是使用筷子还是接着等待。如果一开始两个人同时表明自己想要筷子的话，对方都会考虑到礼仪问题，谦让给对方用，毕竟谁叫他们叫孔融呢，但是这样出现的问题就是明明有筷子可以用但是因为谦让而僵持住。结果两个人就只能饿着了，在操作系统里面这里就出现了”死等”，即会存在进程产生”饥饿”。</p>
<p>该比喻来自 CSDN「叫我蘑菇先生」的<a class="link" href="https://blog.csdn.net/weixin_43305485/article/details/120754983">原创文章<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<hr>
<h3 id="Peterson-算法"><a href="#Peterson-算法" class="headerlink" title="Peterson 算法"></a>Peterson 算法</h3><p>基本思路：设置一个数组<code> flag[2]</code>，这里与前面不同之处，先设置自己的标志位，再检查对方的标志状态，若对方的标志位为 <code>true</code>，再检查对方的标志状态，若对方的标志位为 <code>true</code> 则等待，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> flag[] = {<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>};<br><span class="hljs-type">int</span> turn = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">p0</span><span class="hljs-params">()</span></span>{<br>    flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;              <span class="hljs-comment">//标记P0希望进入临界区</span><br>  turn = <span class="hljs-number">1</span>;<br>    <br>  <span class="hljs-built_in">wait</span>(flag[<span class="hljs-number">1</span>] &amp;&amp; turn == <span class="hljs-number">1</span>);<br>    critical section;<br>    flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>    remainder section;<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">p1</span><span class="hljs-params">()</span></span>{<br>    flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>    turn = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-built_in">wait</span>(flag[<span class="hljs-number">0</span>] &amp;&amp; turn == <span class="hljs-number">0</span>);<br>    critical section;<br>    flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>    remainder section;<br>}<br></code></pre></td></tr></table></figure>

<blockquote>
<p>此算法利用flag[ ]实现了临界资源的<strong>互斥访问</strong>，并用<strong>turn</strong>解决了“<strong>饥饿</strong>”现象；</p>
<p>遵循了空闲让进、忙则等待和有限等待原则；</p>
<p>但是<strong>没有遵循让权等待原则</strong>（需要在CPU上不断循环检测）。</p>
</blockquote>
<h2 id="硬件实现"><a href="#硬件实现" class="headerlink" title="硬件实现"></a>硬件实现</h2><h3 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a>中断屏蔽方法</h3><p>利用开关中断的方式实现</p>
<pre class="mermaid">graph TB
close(关中断)
critical(临界区)
open(开中断)
close--"关中断之后不允许当前进程被关闭"--&gt;critical--&gt;open</pre>

<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>简洁，高校</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><p>不适用于多处理机</p>
</li>
<li><p>只适用于操作系统内核进程（开关中断只能在内核执行）</p>
</li>
</ul>
<h3 id="TSL-TestAndSet-指令"><a href="#TSL-TestAndSet-指令" class="headerlink" title="TSL(TestAndSet)指令"></a>TSL(TestAndSet)指令</h3><p><strong>TS/TSL</strong> 指令时用<strong>硬件</strong>实现的，执行过程不允许被中断。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> lock;  <span class="hljs-comment">//共享变量表示临界资源是否上锁</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TSL</span><span class="hljs-params">(<span class="hljs-type">bool</span> &amp;g_lock)</span></span>{<br>    <span class="hljs-type">bool</span> old = g_lock;<br>    g_lock = <span class="hljs-literal">true</span>;   <span class="hljs-comment">//无论之前是否上锁，将lock设置为true</span><br>    <span class="hljs-keyword">return</span> old; <span class="hljs-comment">//返回之前lock的值</span><br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">p0</span><span class="hljs-params">()</span></span>{<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">TSL</span>(lock));<span class="hljs-comment">//若可以进入临界区，则进入循环</span><br>    critical section;<br>    lock = <span class="hljs-literal">false</span>;  <span class="hljs-comment">//为临界资源解锁</span><br>    remainder section;<br>}<br><br></code></pre></td></tr></table></figure>

<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>实现简单</li>
<li>适用于多处理机环境</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>不满足让权等待原则，暂时无法进入临界区的资源任然会占用 <strong>CPU</strong> 并循环执行 <code>TS</code> 指令，导致<strong>“忙等”</strong></li>
</ul>
<h3 id="Swap-指令"><a href="#Swap-指令" class="headerlink" title="Swap 指令"></a>Swap 指令</h3><p>也称之为 <strong>Exchange</strong> 指令，或者简称 <strong>XCHG</strong>。</p>
<p>该指令和 <strong>TSL</strong> 类似，都是用硬件实现的，执行过程不允许被中断。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> lock;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(<span class="hljs-type">bool</span> &amp;a,<span class="hljs-type">bool</span> &amp;b)</span> </span>{<br>    a = a^b;<br>    b = a^b;<br>    a = a^b;<br>}<br><span class="hljs-type">bool</span> old = <span class="hljs-literal">true</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">p0</span><span class="hljs-params">()</span></span>{<br>    <span class="hljs-keyword">while</span> (old== <span class="hljs-literal">true</span>) <span class="hljs-built_in">Swap</span>(old,lock);<br>    critical section;<br>    lock = <span class="hljs-literal">false</span>;<br>    remainder section;<br>}<br><br><br></code></pre></td></tr></table></figure>

<p>其原理，优缺点和 <strong>TSL</strong> 类似。</p>
]]></content>
      <tags>
        <tag>基础知识</tag>
        <tag>操作系统</tag>
        <tag>进程管理</tag>
        <tag>进程同步</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统知识点总结-进程管理</title>
    <url>/2022/09/09/os-os-process/</url>
    <content><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><blockquote>
<p>进程是资源分配的基本单位。</p>
<p>进程控制块(Process Control Block PCB)描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 <code>PCB</code> 的操作。</p>
</blockquote>
<p>进程控制块包含下列信息：</p>
<h3 id="1-进程标识符（PID）"><a href="#1-进程标识符（PID）" class="headerlink" title="1. 进程标识符（PID）"></a>1. 进程标识符（PID）</h3><p>进程标识符用于唯一地标识一个进程。</p>
<p>一个进程通常由两种标识符组成：</p>
<ul>
<li><h6 id="内部标识符："><a href="#内部标识符：" class="headerlink" title="内部标识符："></a>内部标识符：</h6></li>
</ul>
<p>在所有操作系统中，都为每一个进程赋予了一个唯一的数字标识符，它通常是一个进程的序号，设置内部标识符主要是为了方便系统使用。</p>
<ul>
<li><h6 id="外部标识符："><a href="#外部标识符：" class="headerlink" title="外部标识符："></a>外部标识符：</h6></li>
</ul>
<p>它由创建者提供，通常是由字母、数字组成，往往是由用户（进程）在访问该进程时使用，为了描述进程的家族关系，还应设置父进程标识及子进程标识。此外，还可以设置用户标识，以标识拥有该进程的用户。</p>
<p>可以参考一个指令 </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">kill</span> pid <br><span class="hljs-built_in">kill</span> p_name<br></code></pre></td></tr></table></figure>

<h3 id="2-处理机状态"><a href="#2-处理机状态" class="headerlink" title="2. 处理机状态"></a>2. 处理机状态</h3><p>处理机状态信息主要由处理机的各种寄存器的内容组成。</p>
<p>包括： <code>通用寄存器</code>、<code>指令计数器</code>、<code>程序状态字 PSW </code>、<code>用户栈指针</code></p>
<p>这些信息显然和进程相关，因此，进程一旦被中断，就必须把这些信息保存在 <code>PCB</code> 中，以便在恢复运行时能完全恢复中断前的状态。</p>
<h3 id="3-进程调度信息"><a href="#3-进程调度信息" class="headerlink" title="3. 进程调度信息"></a>3. 进程调度信息</h3><p>在 PCB 中还存放一些进程调度和进程对换相关的信息。</p>
<p>包括：<code>进程状态</code>、<code>进程优先级</code>、<code>进程调度所需要的其他信息</code>（所采用的进程调度算法有关），<code>事件</code>（指进程由执行状态变为阻塞态所等待发生的事件，即阻塞原因）</p>
<h3 id="4-进程控制信息"><a href="#4-进程控制信息" class="headerlink" title="4. 进程控制信息"></a>4. 进程控制信息</h3><ul>
<li><p>程序和数据的地址。</p>
</li>
<li><p>进程同步和通信机制，指实现进程同步和进程通信时必须的机制，如消息队列的指针、信号量等，他们可能全部或部分的放在 <code>PCB</code>中。</p>
</li>
<li><p>资源清单，列出了出 <code>CPU</code>以外的、进程所需的全部资源及已经分配到改进程的资源清单。</p>
</li>
<li><p>链接指针，他给出了本进程（<code>PCB</code>）所在队列的下一个进程的 <code>PCB</code> 的首地址。</p>
</li>
</ul>
<pre class="mermaid">classDiagram
    class PCB
    PCB : +唯一标识符
    PCB : +状态机信息
    PCB : +进程调度信息
    PCB : +进程控制信息</pre>

<h3 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h3><ol>
<li><h5 id="动态性（进程的基本特征）"><a href="#动态性（进程的基本特征）" class="headerlink" title="动态性（进程的基本特征）"></a>动态性（进程的基本特征）</h5><p> 进程是程序的一次执行过程，是动态地产生，变化和消亡</p>
</li>
<li><h5 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h5><p> 内存中有多个进程实体，各进程可并发执行</p>
</li>
<li><h5 id="独立性"><a href="#独立性" class="headerlink" title="独立性"></a>独立性</h5><p> 进程是<strong>独立运行</strong>，<strong>独立获得资源</strong>，<strong>独立接受调度</strong>的<strong>基本单位</strong></p>
</li>
<li><h5 id="异步性"><a href="#异步性" class="headerlink" title="异步性"></a>异步性</h5><p> 各进程按各自独立的，不可预知的速度向前推进，操作系统要提供”<strong>进程同步机制</strong>“来解决异步问题</p>
</li>
<li><h5 id="结构性"><a href="#结构性" class="headerlink" title="结构性"></a>结构性</h5><p> 每个进程都会配置一个 <strong>PCB</strong> ，结构上看，进程由程序段，数据段，<strong>PCB</strong> 组成</p>
</li>
</ol>
<h3 id="进程态的切换"><a href="#进程态的切换" class="headerlink" title="进程态的切换"></a>进程态的切换</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://camo.githubusercontent.com/0398c2bace5b1b0695f5a34f6cfedf6e358db565408abc83dd161de71d3bfec8/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f50726f6365737353746174652e706e67" alt="img"></p>
<ul>
<li>创建态(created): <strong>进程</strong>正在被创建，包括建立空白 <strong>PCB</strong>，由系统为进程分配资源等。</li>
</ul>
<h4 id="基本状态"><a href="#基本状态" class="headerlink" title="基本状态"></a>基本状态</h4><ul>
<li><p>就绪状态(<code>ready</code>): <strong>进程</strong>获得了除了<strong>处理机外的一切资源</strong>，一旦获得了处理及资源就可以立刻开始运行，系统中处于就绪态的进程可以由很多个，通常将他们排成一个队列，称为就绪队列。</p>
</li>
<li><p>运行状态(<code>running</code>)：<strong>进程</strong>正在处理机上运行。单处理机情况下每一每刻最多只有一个进程处于运行态。</p>
</li>
<li><p>阻塞状态(<code>waiting</code>): <strong>进程</strong>请求等待某个事件发生，在该事件完成前，即使处理机资源空闲，该进程也不能运行，例如请求了系统调用或者是等待某些资源。</p>
</li>
</ul>
<hr>
<ul>
<li>中止态(<strong>dead</strong>): 进程正在结束。系统先将进程置为结束态，之后再进行资源的释放和回收等工作。</li>
</ul>
<blockquote>
<p>需要注意:</p>
<ul>
<li>只有就绪态和运行态可以相互转换,其他的都是单向转换,就绪状态的进程通过调度算法从而获得 <code>CPU</code> 事件,转为运行状态;而运行状态的进程,在分配给他的 CPU 时间片用完之后就会转为就绪状态,等待下一次调度。</li>
<li>阻塞状态是缺少需要的资源从而由运行状态转换而来,但是该资源不包括<code>CPU</code>时间,缺少<code>CPU</code> 时间会从运行态转换为就绪态。</li>
<li>运行态道阻塞态<strong>一般</strong>是<strong>主动</strong>的行为。</li>
<li>阻塞态道就绪态是被动的行为。</li>
</ul>
</blockquote>
<h3 id="进程的组织方式"><a href="#进程的组织方式" class="headerlink" title="进程的组织方式"></a>进程的组织方式</h3><ul>
<li>链式方式：将同一状态的 <strong>PCB</strong> 连接道同一个队列</li>
<li>索引方式：将同一状态的 <strong>PCB</strong> 放在同一个索引表中</li>
</ul>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>进程控制是用<strong>原语</strong>来实现的：</p>
<blockquote>
<p>tips:</p>
<p>原语是指执行期间不允许终中断的程序段，是同一个不可分割的基本单位。</p>
<p>通过”<strong>关中断指令</strong>“和”<strong>开中断指令</strong>“实现了原语的<strong>原子性</strong></p>
</blockquote>
<h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><h5 id="创建原语"><a href="#创建原语" class="headerlink" title="创建原语"></a>创建原语</h5><ol>
<li>申请空白 <strong>PCB</strong></li>
<li>为进程分配所需资源</li>
<li>初始化 <strong>PCB</strong></li>
<li>将 PCB 插入就绪队列（创建态-&gt;就绪态）</li>
</ol>
<pre class="mermaid">graph TB;
start(申请空白的PCB);
assign(分配所需资源);
init(初始化 PCB);
insert(将 PCB 插入就绪队列);
%%  开始连接
start--&gt;assign--&gt;init--&gt;insert;</pre>



<h5 id="引起进程创建的事件"><a href="#引起进程创建的事件" class="headerlink" title="引起进程创建的事件"></a>引起进程创建的事件</h5><ol>
<li>用户登陆</li>
<li>作业调度（有新的作业将要运行）</li>
<li>提供服务</li>
<li>应用请求（用户进程主动请求创建子进程）</li>
</ol>
<h4 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h4><h5 id="撤销原语"><a href="#撤销原语" class="headerlink" title="撤销原语"></a>撤销原语</h5><ol>
<li>从 <strong>PCB</strong> 集合中找到终止进程的 <strong>PCB</strong></li>
<li>若进程正在运行，立刻剥夺 <strong>CPU</strong>，将 <strong>CPU</strong> 分配给其他进程</li>
<li>中止其所有的子进程</li>
<li>将该进程的所有资源归还给父进程或是操作系统</li>
<li>删除 <strong>PCB</strong></li>
</ol>
<pre class="mermaid">graph TB;
kill(找到终止进程);
checkStatus
assign(立刻剥夺 CPU);
stopChildProcess(终止其子进程);
delete(删除所有的 PCB);
%%  开始连接
kill--&gt;checkStatus
checkStatus--正在运行==&gt;assign--&gt;stopChildProcess
checkStatus--其他状态==&gt;stopChildProcess
stopChildProcess--&gt;delete</pre>



<h5 id="引起进程终止的事件"><a href="#引起进程终止的事件" class="headerlink" title="引起进程终止的事件"></a>引起进程终止的事件</h5><ul>
<li><p>正常结束</p>
</li>
<li><p>异常结束</p>
</li>
<li><p>外界干预</p>
</li>
</ul>
<h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a><span id="process-switch">进程切换</span></h4><h5 id="切换原语"><a href="#切换原语" class="headerlink" title="切换原语"></a>切换原语</h5><ol>
<li>将运行环境信息存入 <strong>PCB</strong></li>
<li>将 <strong>PCB</strong> 移入相应队列</li>
<li>选择另一个进程执行，并更新其 <strong>PCB</strong></li>
<li>根据 <strong>PCB</strong> 恢复进程所需的运行环境</li>
</ol>
<h6 id="引起切换的事件"><a href="#引起切换的事件" class="headerlink" title="引起切换的事件"></a>引起切换的事件</h6><ul>
<li>当前进程<strong>时间片</strong>到，该被处理了</li>
<li>更高级的进程到达</li>
<li>当前进程主动阻塞</li>
<li>当前进程中止</li>
</ul>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><h4 id="1-共享存储"><a href="#1-共享存储" class="headerlink" title="1. 共享存储"></a>1. 共享存储</h4><ul>
<li><p>两个进程对共享空间的访问必须时互斥的（临界资源）</p>
</li>
<li><p>操作系统只提供<strong>共享空间</strong>和<strong>同步互斥工具</strong>（P,V操作）</p>
<blockquote>
<p>主要有两种方式:</p>
<ul>
<li>基于数据结构的共享<ul>
<li>只能共享固定的数据结构</li>
<li>速度慢，是一种低效的共享方式</li>
</ul>
</li>
<li>基于存储区的共享<ul>
<li>共享方式和大小由进程自己决定</li>
<li>速度快，是一种高级的共享方式</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="2-管道通信"><a href="#2-管道通信" class="headerlink" title="2. 管道通信"></a>2. 管道通信</h4><ul>
<li><p>管道是半双工的，先进先出的，它把一个进程的输出和另一个进程的输入连接在一起</p>
</li>
<li><p>一个进程（写进程）在管道的尾部写入数据，另一个进程（读进程）从管道的头部读出数据</p>
</li>
<li><p>无名管道用于父子进程之间的通信；有名管道用于运行同一个系统中的任意两个进程间的通信</p>
</li>
<li><p>各个进程对管道的访问是互斥的</p>
</li>
<li><p>管道没有写满的时候，不能向管道中再写（读）数据</p>
</li>
<li><p>从管道中读取数据是一次性的，数据一旦被读取就会从管道中抛弃</p>
</li>
<li><p>一次只能由一个<strong>读进程</strong>，但是可以有多个<strong>写进程</strong></p>
<blockquote>
<p>无名管道：创建管道——读管道——写管道——关闭管道</p>
<p>有名管道：创建管道——删除管道——打开管道——关闭管道——读管道——写管道</p>
</blockquote>
</li>
</ul>
<h4 id="3-消息传递"><a href="#3-消息传递" class="headerlink" title="3. 消息传递"></a>3. 消息传递</h4><blockquote>
<p>进程间的数据交换以格式化消息（message）为单位。</p>
<p>通过<strong>发送消息/接收消息</strong>两个原语进行</p>
</blockquote>
<h5 id="直接通信方式"><a href="#直接通信方式" class="headerlink" title="直接通信方式"></a>直接通信方式</h5><p>发送进程直接将消息发送到接受进程的<strong>消息缓冲队列</strong>中</p>
<h5 id="间接通信方式"><a href="#间接通信方式" class="headerlink" title="间接通信方式"></a>间接通信方式</h5><p>发送进程将消息发送到某个中间实体，一般为__信箱__，接收端从中间实体接受消息</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>线程是独立调度的<strong>基本单位</strong>。</p>
<p>一个进程中可以由多个线程，他们共享进程资源。</p>
<p>比如：QQ和浏览器是两个进程，浏览器中里面由很多线程，竟然刚好探讨到了浏览器的线程，值得一提的是单个页面基本有五种线程构成，包含插件线程，网络请求线程，计时器线程，渲染线程，事件触发线程（DomEvent），JS 线程。这里可以知道线程之间是可以共享资源 (HTML)的，但是浏览器的运行与QQ之间是不可通信的，资源是不共享的，QQ又有自己的进程，其下还有自己的线程。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><h4 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h4><p>线程作为独立调度的基本单位，进程内的线程调度不会引起<a href="#process-switch">进程切换</a>，开销更小。</p>
<h4 id="并发性-1"><a href="#并发性-1" class="headerlink" title="并发性"></a>并发性</h4><ul>
<li>同一进程内的线程可以并发运行。</li>
<li>不同进程间内的线程可以并发运行。</li>
</ul>
<h4 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h4><ul>
<li>线程几乎不占有资源，而是共享进程资源。</li>
</ul>
<h4 id="支持多处理机系统"><a href="#支持多处理机系统" class="headerlink" title="支持多处理机系统"></a>支持多处理机系统</h4><ul>
<li>可以将多个线程分配给多个处理机运行。</li>
</ul>
<h3 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h3><p>线程库支持的线程（用户级线程 <strong>User-Level Threed,ULT</strong>）</p>
<ul>
<li>线程的切换由应用程序负责，在用户态下即可完成。</li>
<li>线程表存储在用户空间，系统内核意识下到线程的存在。</li>
<li>调度：<ul>
<li>操作系统为进程分配时间片。</li>
<li>用户的调度程序再将时间片分给线程。</li>
</ul>
</li>
<li>优点<ul>
<li>线程的切换在用户态即可完成，<strong>开销小</strong>，<strong>效率高</strong>。</li>
</ul>
</li>
<li>缺点<ul>
<li>当<strong>一个线程阻塞</strong>后，其他线程<strong>都会被阻塞</strong>，并发度不高。</li>
</ul>
</li>
</ul>
<h3 id="多线程模式"><a href="#多线程模式" class="headerlink" title="多线程模式"></a>多线程模式</h3><h4 id="一对一模式"><a href="#一对一模式" class="headerlink" title="一对一模式"></a>一对一模式</h4><p>一个用户级线程映射一个内核级线程（一个 <strong>UTL</strong> 一个 <strong>TCB</strong>(<strong>Thread Control Block</strong>))</p>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li>并发能力强</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>开销大</li>
</ul>
<h4 id="多对一模式"><a href="#多对一模式" class="headerlink" title="多对一模式"></a>多对一模式</h4><p>将多个用户级线程映射到一个内核级线程，等同于用户级线程（多个 <strong>UTL</strong> 一个 <strong>TCB</strong>）</p>
<h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul>
<li>效率高</li>
</ul>
<h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>并发能力弱，多个线程不能并行的运行在多个处理机上</li>
</ul>
<h4 id="多对多模式"><a href="#多对多模式" class="headerlink" title="多对多模式"></a>多对多模式</h4><p>将 n 个 ULT 映射到  m 个内核级线程（ m &lt;= n）</p>
<h3 id="线程的控制"><a href="#线程的控制" class="headerlink" title="线程的控制"></a>线程的控制</h3><h5 id="线程的切换"><a href="#线程的切换" class="headerlink" title="线程的切换"></a>线程的切换</h5><pre class="mermaid">graph LR
Wait((就绪))
Running((运行))
Stop((阻塞))

classDef default fill: #f9a, stroke: #333, stroke-width: 4px;

Wait--    "③被调度程序选中" --&gt;Running
Running --"②时间用完"      --&gt; Wait
Stop --   "④等待事件发生"   --&gt;Wait
Running-- "①等待某事件"    --&gt;Stop</pre>



<h4 id="线程的组织与控制"><a href="#线程的组织与控制" class="headerlink" title="线程的组织与控制"></a>线程的组织与控制</h4><p>将 TCB 组织成线程表进行管理</p>
<pre class="mermaid">classDiagram
    class TCB
    TCB : +线程控制标识符
    TCB : +线程计数器
    TCB : +其他寄存器信息，存放中间结果
    TCB : +堆栈指针
    TCB : +线程运行状态["Wait Runing Jam"]
    TCB : +优先级</pre>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>资源</li>
</ul>
<p>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问所属进程的资源</p>
<ul>
<li>调度</li>
</ul>
<p>线程是独立调度的基本单位，在同一个进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换</p>
<ul>
<li>系统开销</li>
</ul>
<p>由于创建或撤销进程时,系统都要为之分配或回收资源，如内存空间，I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。在进行进程切换时，涉及当前执行进程 <code>CPU</code> 环境的保存及新调度进 <code>CPU</code> 环境的设置，而线程切换时只需要设置和保存少量的少量的寄存器内容，故开销也很小。</p>
<ul>
<li>通信方面</li>
</ul>
<p>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 <code>PIC</code>。</p>
]]></content>
      <tags>
        <tag>基础知识</tag>
        <tag>操作系统</tag>
        <tag>进程管理</tag>
        <tag>进程与线程</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML 基础篇</title>
    <url>/2022/09/07/html-HTML-base/</url>
    <content><![CDATA[<h1 id="HTML-基础总结"><a href="#HTML-基础总结" class="headerlink" title="HTML 基础总结"></a>HTML 基础总结</h1><h2 id="SEO-相关内容"><a href="#SEO-相关内容" class="headerlink" title="SEO 相关内容"></a>SEO 相关内容</h2><p>所谓 SEO ，就是搜索引擎索引优化，让搜索引擎更容易定位到网站内容，然而对于一个网站，最重要的便是 HTML，提供完整的内容是 web 出现的首要原因，一个好的网站不应该脱离内容，功能主体。</p>
<h3 id="1-HTML-语义化的理解"><a href="#1-HTML-语义化的理解" class="headerlink" title="1. HTML 语义化的理解"></a>1. HTML 语义化的理解</h3><p>Web语义化是指使用恰当语义的<code>html</code>标签、<code>class</code>类名等内容，让页面具有良好的结构与含义，从而让人和机器都能快速理解网页内容。语义化的<code>web</code>页面一方面可以让机器在更少的人类干预情况下收集并研究网页的信息，从而可以读懂网页的内容，然后将收集汇总的信息进行分析，结果为人类所用；另一方面它可以让开发人员读懂结构和用户以及屏幕阅读器（如果访客有视障）能够读懂内容。</p>
<p>简而言之，一种 <code>Web </code>开发规范，规范的作用就有：</p>
<ol>
<li>更好的维护项目，提高代码可读性。</li>
<li>机器更容易理解内容，那么对于 <code>SEO</code>,<code>Aria </code>都有帮助，同时有利于编译器进行一系列优化。</li>
</ol>
<h3 id="2-h1-标签和-title-标签之间的区别是什么？"><a href="#2-h1-标签和-title-标签之间的区别是什么？" class="headerlink" title="2. h1 标签和 title 标签之间的区别是什么？"></a>2. h1 标签和 title 标签之间的区别是什么？</h3><ul>
<li><code>h1</code>标签：写在文章正文的标题部分，参与文章的内容部分，对于一个页面最好只有一个主题，更好彰显主题。</li>
<li><code>title</code>标签：写在网页的 <code>head</code> 部分，不参与文章的内容，是展示给搜索引擎的，对于 <code>SEO</code> 而言其权重无疑是最大的，其次，会作为浏览器标签卡，并会保留在历史记录中。</li>
</ul>
<h3 id="3-lt-img-x2F-gt-中的-title-属性和-alt-属性的区别"><a href="#3-lt-img-x2F-gt-中的-title-属性和-alt-属性的区别" class="headerlink" title="3. <img /> 中的 title 属性和 alt 属性的区别"></a>3. &lt;img /&gt; 中的 title 属性和 alt 属性的区别</h3><p><code>alt</code> 属性是在图片无法加载的时候才会显示的代替文本，对于 <code>alt</code> 的作用是易用性的一个重要信息，屏幕阅读器会提示出来，而 <code>title</code> 是关于元素的注释信息，主要是给用户解读，当鼠标放到文字或是图片上时有 <code>title</code> 文字显示。这两者的区别就类似于我们所说的 <code>em</code>和 <code>strong</code> 的区别</p>
]]></content>
      <categories>
        <category>HTML</category>
        <category>2023面试</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>2023面试</tag>
      </tags>
  </entry>
</search>
