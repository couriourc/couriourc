<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HTML 基础篇</title>
    <url>/2022/09/07/html-HTML-base/</url>
    <content><![CDATA[<h1 id="HTML-基础总结"><a href="#HTML-基础总结" class="headerlink" title="HTML 基础总结"></a>HTML 基础总结</h1><h2 id="SEO-相关内容"><a href="#SEO-相关内容" class="headerlink" title="SEO 相关内容"></a>SEO 相关内容</h2><p>所谓 SEO ，就是搜索引擎索引优化，让搜索引擎更容易定位到网站内容，然而对于一个网站，最重要的便是 HTML，提供完整的内容是 web 出现的首要原因，一个好的网站不应该脱离内容，功能主体。</p>
<h3 id="1-HTML-语义化的理解"><a href="#1-HTML-语义化的理解" class="headerlink" title="1. HTML 语义化的理解"></a>1. HTML 语义化的理解</h3><p>Web语义化是指使用恰当语义的<code>html</code>标签、<code>class</code>类名等内容，让页面具有良好的结构与含义，从而让人和机器都能快速理解网页内容。语义化的<code>web</code>页面一方面可以让机器在更少的人类干预情况下收集并研究网页的信息，从而可以读懂网页的内容，然后将收集汇总的信息进行分析，结果为人类所用；另一方面它可以让开发人员读懂结构和用户以及屏幕阅读器（如果访客有视障）能够读懂内容。</p>
<p>简而言之，一种 <code>Web </code>开发规范，规范的作用就有：</p>
<ol>
<li>更好的维护项目，提高代码可读性。</li>
<li>机器更容易理解内容，那么对于 <code>SEO</code>,<code>Aria </code>都有帮助，同时有利于编译器进行一系列优化。</li>
</ol>
<h3 id="2-h1-标签和-title-标签之间的区别是什么？"><a href="#2-h1-标签和-title-标签之间的区别是什么？" class="headerlink" title="2. h1 标签和 title 标签之间的区别是什么？"></a>2. h1 标签和 title 标签之间的区别是什么？</h3><ul>
<li><code>h1</code>标签：写在文章正文的标题部分，参与文章的内容部分，对于一个页面最好只有一个主题，更好彰显主题。</li>
<li><code>title</code>标签：写在网页的 <code>head</code> 部分，不参与文章的内容，是展示给搜索引擎的，对于 <code>SEO</code> 而言其权重无疑是最大的，其次，会作为浏览器标签卡，并会保留在历史记录中。</li>
</ul>
<h3 id="3-lt-img-x2F-gt-中的-title-属性和-alt-属性的区别"><a href="#3-lt-img-x2F-gt-中的-title-属性和-alt-属性的区别" class="headerlink" title="3. <img /> 中的 title 属性和 alt 属性的区别"></a>3. &lt;img /&gt; 中的 title 属性和 alt 属性的区别</h3><p><code>alt</code> 属性是在图片无法加载的时候才会显示的代替文本，对于 <code>alt</code> 的作用是易用性的一个重要信息，屏幕阅读器会提示出来，而 <code>title</code> 是关于元素的注释信息，主要是给用户解读，当鼠标放到文字或是图片上时有 <code>title</code> 文字显示。这两者的区别就类似于我们所说的 <code>em</code>和 <code>strong</code> 的区别</p>
]]></content>
      <categories>
        <category>HTML</category>
        <category>2023面试</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>2023面试</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统知识点总结-概览</title>
    <url>/2022/09/08/os-os-overview/</url>
    <content><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>操作系统个人认为更像是竞争问题，对于 CPU 的算力分配，和进程之间的分配问题，既要高效，又要健壮稳定。</p>
<pre class="mermaid">graph LR
    %% Graph 图，待处理解析展示
    Center((操作系统))
    
    Center --&gt; basePersonility(基本特征)
    basePersonility--&gt;并发
    basePersonility--&gt;共享
    basePersonility--&gt;虚拟
    basePersonility--&gt;异步
    
    Center --&gt; baseFunction(基本功能)
    baseFunction--&gt;进程管理
    baseFunction--&gt;内存管理
    baseFunction--&gt;文件管理
    baseFunction--&gt;设备管理

    Center--根据系统功能分类--&gt;sysInner(内核)
    sysInner--系统功能全在内核--&gt;marco(宏内核)
    sysInner--除核心功能之外的系统功能在内部--&gt;mirco(微内核) 
    sysInner--结合宏内核和微内核的特点--&gt;minixco(混合内核)
    
    Center--&gt;sysCall(系统调用)
    
    Center--&gt;interperter(中断分类)
    interperter--CPU执行指令之外的事件--&gt;外中断
    interperter--CPU执行内部事件引起的事件---&gt;异常
    interperter--在用户程序中使用的系统调用--&gt;陷入</pre>



<h2 id="基础特征"><a href="#基础特征" class="headerlink" title="基础特征"></a>基础特征</h2><h3 id="1-并发"><a href="#1-并发" class="headerlink" title="1. 并发"></a>1. 并发</h3><blockquote>
<p>并发是指宏观上在一段时间内能同时运行多个程序，而并行则是指同一时刻能运行多个指令。</p>
<p>并行需要硬件支持，如多流水线，多核处理器或者分布式计算系统。</p>
<p>操作系统通过引入进程和线程，使得程序能够并发运行。</p>
</blockquote>
<p>并发运行并不是真真的同时完成多个任务，而是 <code>CPU</code> 的高速处理，使得各个任务之间来回进行，完成各个任务，而并行也就是我们实际业务希望解决的问题，但是对应带来的成本问题也就出现了。</p>
<!--TODO: 处理 Hexo 时序图问题--->

<pre class="mermaid">sequenceDiagram
    Note left of A: 进程A
    Note right of B: 进程B
    Note over A,B: CPU 在 AB 之间快速切换</pre>

<h3 id="2-共享"><a href="#2-共享" class="headerlink" title="2. 共享"></a>2. 共享</h3><blockquote>
<p>共享是指系统中的资源可以被多个并发进程共同使用。</p>
<p>主要有两种共享方式：<strong>互斥共享</strong>和<strong>同时共享</strong>。</p>
<p>互斥共享的资源被称为临界资源，特点是同时只能有一个占用，比如对于打印机这种外接设备，在同时只能允许一个进程访问，需要用同步机制实现互斥访问，有点类似队列结构（FIFO）。</p>
</blockquote>
<pre class="mermaid">sequenceDiagram
    participant A
    participant B
    Note over A,B: 按照顺序的去进入同一个进程，或者说叫做被同一个进程依次占有，就像打印机队列那样</pre>



<h3 id="3-虚拟"><a href="#3-虚拟" class="headerlink" title="3. 虚拟"></a>3. 虚拟</h3><blockquote>
<p>虚拟技术把一个物理实体转换为多个逻辑实体。</p>
<p>主要有两种虚拟技术：时（时分复用技术）、空（空分复用技术）。</p>
<p>多个进程能在同一个处理器上并发执行也就利用了时分复用技术，让每一个进程轮流占用处理器，每次只执行一小个时间片，并快速切换。</p>
<p>虚拟内存则是使用了空分复用技术，他将物理内存抽象为地址空间，每一个进程都有各自的地址空间，地址空间的也被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有物理内存的页时，执行页面置换算法，将该页置换到内存中。</p>
<p>虚拟内存的关键问题：主要有调度问题、地址映射问题、替换问题、更新问题（要确保主存与辅存的一致性）</p>
</blockquote>
<p>个人认为，虚拟的好处在于可控，让每一步操作是出于可被控制可被调度的，也就使得可优化，更加稳定。</p>
<h3 id="4-异步"><a href="#4-异步" class="headerlink" title="4. 异步"></a>4. 异步</h3><blockquote>
<p>异步进程不是一次性排队完成，而是走走停停，每一步耗费的时间是不可知的</p>
</blockquote>
<p>异步和同步各自有不同的应用场景，不只是在操作系统上的概念，在各大编程语言上也有不同的信息。</p>
<h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><h3 id="1-进程管理"><a href="#1-进程管理" class="headerlink" title="1. 进程管理"></a>1. 进程管理</h3><blockquote>
<p><strong>进程控制</strong>，<strong>进程同步</strong>，<strong>进程通信</strong>，<strong>死锁处理</strong>，<strong>处理机调度</strong>等；</p>
</blockquote>
<ol>
<li><p>进程控制的主要功能是对系统中所有进程实施有效的管理，它具有创建新进程（<strong>fork</strong>），撤销已有进程，实现进程状态转换的功能；</p>
</li>
<li><p>进程同步，也就是异步环境下的一组并发进程因直接制约而互相发送消息，进行互相合作，互相等待，使得各个进程按一定的速度执行的过程，成为进程间的同步，具有同步关系的一组并发进程称为合作进程，合作进程互相发送的信号成为消息或事件，对这样的消息或者事件给一个名称，则我们可用 wait(消息名)表示经常等待合作进程发来的消息，而用过程 signal(消息名)表示像合作进程发送消息。</p>
<p>进程同时处理同一串数据，会造成不确定性，有多个进程同时对一个文件进行读写，那么读文件的进程无法确定督导的数据是它本来想要的数据（老数据），还是被修改的数据（新数据 <code>modified data</code>），除此之外，当先读后写的时候，由于缓冲区没有写入数据，读进程无数据可读，就进入了阻塞态。</p>
<p>这种两个或多个进程读写某些共享数据，而最后的结果却决于进行的精准时序，称为数据竞争，而这种多个程序可以并发执行，但是由于系统资源有限，程序的执行不是一贯到底的，而是以不可预知的速度推进的，这也就是之前说的<strong>异步性</strong>。</p>
<p>这种受到访问顺序限制的的数据是没有意义的（对于程序运行不能有二义性，也就是某一个状态是确定的），所以为了能够使得进程有一定的顺序来访问数据，从而引入了同步的概念。</p>
<p>对于资源是如此，对于数据库操作同样也是如此。</p>
<p>而之前所说的信号，下述便是对于用信号量实现进程同步的步骤，主要分为 PV 两大操作。</p>
<p><strong>信号量</strong>的作用就是控制多进程共享资源的访问（资源有限并且不共享），其本质是任一时刻只能有一个进程访问临界区（代码）数据更新的代码。</p>
<h4 id="PV操作"><a href="#PV操作" class="headerlink" title="PV操作"></a>PV操作</h4><p>PV操作即是针对信号量进行的相应操作，PV操作由P操作原语和V操作原语组成（原语是不可中断的过程）。</p>
<h4 id="P-操作"><a href="#P-操作" class="headerlink" title="P 操作"></a>P 操作</h4><p>当进程执行P操作，若信号量大于零（有共享资源），则信号量减一，进程继续执行；若信号量为零，则进程等待。</p>
 <pre class="mermaid">    graph TB
     start(P 操作)--&gt;isSingleN{信号量}
     isSingleN---大于0--&gt; down(信号量减一)
     isSingleN---等于0--&gt; wait(等待)</pre>

<h4 id="V-操作"><a href="#V-操作" class="headerlink" title="V 操作"></a>V 操作</h4><p>当进程执行 V 操作 ，若信号量大于零（有共享资源），则信号量加一；若信号量为零，则唤醒等待进程。</p>
 <pre class="mermaid">    graph TB
     start(V 操作)--&gt;isSingleN{信号量}
     isSingleN---大于0--&gt; down(信号量减一)
     isSingleN---等于0--&gt; wait(等待)</pre></li>
</ol>
<h3 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2. 内存管理"></a>2. 内存管理</h3><blockquote>
<p><strong>内存分配</strong>，<strong>地址映射</strong>，<strong>内存保护与共享</strong>，<strong>虚拟内存</strong>等</p>
</blockquote>
<p>内存的管理分为文件内存，和运行内存，对于进程管理比较重要的就是运存的管理了。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pica.zhimg.com/v2-4c9fcddd65b35e84c4c6783aaeee3826_1440w.jpg?source=172ae18b" alt="操作系统—内存管理"></p>
<h3 id="3-文件管理"><a href="#3-文件管理" class="headerlink" title="3. 文件管理"></a>3. 文件管理</h3><blockquote>
<p>文件存储空间的管理、目录管理、文件读写管理和保护等</p>
</blockquote>
<h3 id="4-设备管理"><a href="#4-设备管理" class="headerlink" title="4. 设备管理"></a>4. 设备管理</h3><blockquote>
<p>完成用户的 I/O 请求。为方便用户使用各种设备。并提高设备的利用率。</p>
<p>主要包括缓冲管理、设备分配、设备处理、虚拟设备等</p>
</blockquote>
<p>这是对外的扩展。比如一些键盘。鼠标的信号输入处理。除此之外。网络 I/O 。需要注意的是，文件 I/O 和这种I/O 是由区别的，文件 I/O，更多的偏向于软件层面，</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2186c6a7b85642089000f57d49a3e58c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p>
<blockquote>
<p>我们日常讨论的网络通信本质上就是网络I/O，通过网络I/O，我们可以和远程设备进行通信（数据交换）。由于网络I/O和正常的磁盘I/O在性能和访问方式上有较大的差异，所以针对磁盘I/O的读写方法也就无法适用于网络I/O身上，大部分操作系统针对网络I/O抽象除了一套特殊的接口—— <strong>网络Socket接口</strong> ，用于对网络I/O进行操作。当然，上面也说了，在Linux当中“一切皆文件”，为了统一概念，Socket在Linux当中也是通过文件描述符来进行描述的，只不过这个文件描述符描述的不是本地文件，而是远程设备对应的文件。<br>作者：Brucebat<br>链接：<a class="link" href="https://juejin.cn/post/7022249649511596063">https://juejin.cn/post/7022249649511596063<i class="fas fa-external-link-alt"></i></a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<p>对于 I/O 而言都是资源的访问，与接受，这两者的在我们使用的时候可能区别不大，但是对于计算机而言，处理的是不一样的信号量，网络 I/O 就像是外部数据的输入，文件 I/O 就如同内部资源的读写，网络 I/O 的另外一方就是通过网桥连接起来，使得信号能够交流.</p>
<p>Linux 的系统调用主要有以下:</p>
<table>
<thead>
<tr>
<th>Task</th>
<th>Commands</th>
</tr>
</thead>
<tbody><tr>
<td>进程控制</td>
<td>fork();exit();wait()</td>
</tr>
<tr>
<td>进程通信</td>
<td>pipe();shmget();mmap();</td>
</tr>
<tr>
<td>文件操作</td>
<td>open();read();write();</td>
</tr>
<tr>
<td>设备操作</td>
<td>ioctl();read();write();</td>
</tr>
<tr>
<td>信息维护</td>
<td>getpid();alarm();sleep();</td>
</tr>
<tr>
<td>安全</td>
<td>chmod();umask();chown();</td>
</tr>
</tbody></table>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而进入内核，有操作系统代为完成。</p>
<p>用户态只能调用受限指令。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img-blog.csdnimg.cn/319223950e3f4d6484f708d710d694da.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><h3 id="1-宏内核"><a href="#1-宏内核" class="headerlink" title="1. 宏内核"></a>1. 宏内核</h3><blockquote>
<p>宏内核是将操作系统功能作为一个紧密结合的整体放到类和。由于各个模块共享信息，因此有很高的性能。</p>
</blockquote>
<p>那么由于宏内核就是将所有的系统调用直接放在一层，那么这样的操作就避免了跨层的调用，因此效果很好，但是带来的问题就是耦合度明显很高，同时安全性也有待商榷。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic3.zhimg.com/80/v2-da9cab3e423cd0634c3752dce1a4ce82_720w.jpg" alt="img"></p>
<h3 id="2-微内核"><a href="#2-微内核" class="headerlink" title="2. 微内核"></a>2. 微内核</h3><p>由于操作系统不断复杂。因此将一部分操作系统功能移出内核(主要是上面描述的系统基本功能)。剩下保留一些核心的如时钟。中断的功能，微内核之间使用了消息通知机制。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://pic3.zhimg.com/80/v2-4aa2bb36f7461989770c6b14bf153776_720w.jpg" alt="img"></p>
<h3 id="总结-摘抄自知乎"><a href="#总结-摘抄自知乎" class="headerlink" title="总结(摘抄自知乎)"></a>总结(摘抄自<a class="link" href="https://zhuanlan.zhihu.com/p/394560786">知乎<i class="fas fa-external-link-alt"></i></a>)</h3><blockquote>
<p>宏内核其实就是把所有的功能都耦合起来，放在内核中，这样的优势就是性能极高，因为各个功能模块之间是可以直接调用的。缺点就是因为各个模块是相互关联，容易出现一错皆错的问题。</p>
</blockquote>
<blockquote>
<p>而微内核则恰恰相反，它为了降低耦合，内核中只会允许一些核心功能的存在，而其余所有功能都会被移出内核，变成一种特殊的用户进程——服务进程。其优点就是各个模块之间是独立的，不会相互影响，但其性能相比宏内核会大幅度下降。</p>
</blockquote>
<blockquote>
<p>混合内核则是结合上面二者的特点，它与微内核相似，只是会将一些功能模块又放回到内核中去，而不常用的功能模块还是放在用户层中。这样在微内核的基础上，又可以提高性能。</p>
</blockquote>
<p>内核的出现是为了解决系统调用复杂的耦合关系，也让各自的功能划分更加清晰。</p>
<h2 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h2><h3 id="1-外中断"><a href="#1-外中断" class="headerlink" title="1. 外中断"></a>1. 外中断</h3><p>由 CPU 执行指令之外的事件引起，如 I/O 完成终端，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。池外还有时钟中断，控制台中断等。</p>
<h3 id="2-异常"><a href="#2-异常" class="headerlink" title="2. 异常"></a>2. 异常</h3><p>由 CPU 执行指令的内部事件引起，如非法操作码，地址越界，算数溢出等。</p>
<h3 id="3-陷入"><a href="#3-陷入" class="headerlink" title="3. 陷入"></a>3. 陷入</h3><p>在用户程序中使用系统调用。</p>
]]></content>
      <tags>
        <tag>基础知识</tag>
        <tag>操作系统</tag>
        <tag>概览</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统知识点总结-进程管理</title>
    <url>/2022/09/09/os-os-process/</url>
    <content><![CDATA[<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><blockquote>
<p>进程是资源分配的基本单位。</p>
<p>进程控制块(Process Control Block PCB)描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 <code>PCB</code> 的操作。</p>
</blockquote>
<p>进程控制块包含下列信息：</p>
<h5 id="1-进程标识符（PID）"><a href="#1-进程标识符（PID）" class="headerlink" title="1. 进程标识符（PID）"></a>1. 进程标识符（PID）</h5><p>进程标识符用于唯一地标识一个进程。</p>
<p>一个进程通常由两种标识符组成：</p>
<ul>
<li><h6 id="内部标识符："><a href="#内部标识符：" class="headerlink" title="内部标识符："></a>内部标识符：</h6></li>
</ul>
<p>在所有操作系统中，都为每一个进程赋予了一个唯一的数字标识符，它通常是一个进程的序号，设置内部标识符主要是为了方便系统使用。</p>
<ul>
<li><h6 id="外部标识符："><a href="#外部标识符：" class="headerlink" title="外部标识符："></a>外部标识符：</h6></li>
</ul>
<p>它由创建者提供，通常是由字母、数字组成，往往是由用户（进程）在访问该进程时使用，为了描述进程的家族关系，还应设置父进程标识及子进程标识。此外，还可以设置用户标识，以标识拥有该进程的用户。</p>
<p>可以参考一个指令 </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">kill</span> pid <br><span class="hljs-built_in">kill</span> p_name<br></code></pre></td></tr></table></figure>

<h5 id="2-处理机状态"><a href="#2-处理机状态" class="headerlink" title="2. 处理机状态"></a>2. 处理机状态</h5><p>处理机状态信息主要由处理机的各种寄存器的内容组成。</p>
<p>包括： <code>通用寄存器</code>、<code>指令计数器</code>、<code>程序状态字 PSW </code>、<code>用户栈指针</code></p>
<p>这些信息显然和进程相关，因此，进程一旦被中断，就必须把这些信息保存在 <code>PCB</code> 中，以便在恢复运行时能完全恢复中断前的状态。</p>
<h5 id="3-进程调度信息"><a href="#3-进程调度信息" class="headerlink" title="3. 进程调度信息"></a>3. 进程调度信息</h5><p>在 PCB 中还存放一些进程调度和进程对换相关的信息。</p>
<p>包括：<code>进程状态</code>、<code>进程优先级</code>、<code>进程调度所需要的其他信息</code>（所采用的进程调度算法有关），<code>事件</code>（指进程由执行状态变为阻塞态所等待发生的事件，即阻塞原因）</p>
<h5 id="4-进程控制信息"><a href="#4-进程控制信息" class="headerlink" title="4. 进程控制信息"></a>4. 进程控制信息</h5><ul>
<li><p>程序和数据的地址。</p>
</li>
<li><p>进程同步和通信机制，指实现进程同步和进程通信时必须的机制，如消息队列的指针、信号量等，他们可能全部或部分的放在 <code>PCB</code>中。</p>
</li>
<li><p>资源清单，列出了出 <code>CPU</code>以外的、进程所需的全部资源及已经分配到改进程的资源清单。</p>
</li>
<li><p>链接指针，他给出了本进程（<code>PCB</code>）所在队列的下一个进程的 <code>PCB</code> 的首地址。</p>
</li>
</ul>
<pre class="mermaid">classDiagram
    class PCB
    PCB : +唯一标识符
    PCB : +状态机信息
    PCB : +进程调度信息
    PCB : +进程控制信息</pre>

<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是独立调度的基本单位。</p>
<p>一个进程中可以由多个线程，他们共享进程资源。</p>
<p>比如：QQ和浏览器是两个进程，浏览器中里面由很多线程，竟然刚好探讨到了浏览器的线程，值得一提的是单个页面基本有五种线程构成，包含插件线程，网络请求线程，计时器线程，渲染线程，事件触发线程（DomEvent），JS 线程。这里可以知道线程之间是可以共享资源 (HTML)的，但是浏览器的运行与QQ之间是不可通信的，资源是不共享的，QQ又有自己的进程，其下还有自己的线程。</p>
<h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><ul>
<li>资源</li>
</ul>
<p>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问所属进程的资源</p>
<ul>
<li>调度</li>
</ul>
<p>线程是独立调度的基本单位，在同一个进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换</p>
<ul>
<li>系统开销</li>
</ul>
<p>由于创建或撤销进程时,系统都要为之分配或回收资源，如内存空间，I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。在进行进程切换时，涉及当前执行进程 <code>CPU</code> 环境的保存及新调度进 <code>CPU</code> 环境的设置，而线程切换时只需要设置和保存少量的少量的寄存器内容，故开销也很小。</p>
<ul>
<li>通信方面</li>
</ul>
<p>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 <code>PIC</code>。</p>
<h2 id="进程态的切换"><a href="#进程态的切换" class="headerlink" title="进程态的切换"></a>进程态的切换</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://camo.githubusercontent.com/0398c2bace5b1b0695f5a34f6cfedf6e358db565408abc83dd161de71d3bfec8/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f50726f6365737353746174652e706e67" alt="img"></p>
<ul>
<li><p>就绪状态(<code>ready</code>): 等待被调度</p>
</li>
<li><p>运行状态(<code>running</code>)</p>
</li>
<li><p>阻塞状态(<code>waiting</code>): 等待资源</p>
</li>
</ul>
<blockquote>
<p>需要注意:</p>
<ul>
<li>只有就绪态和运行态可以相互转换,其他的都是单向转换,就绪状态的进程通过调度算法从而获得 <code>CPU</code> 事件,转为运行状态;而运行状态的进程,在分配给他的 CPU 时间片用完之后就会转为就绪状态,等待下一次调度.</li>
<li>阻塞状态是缺少需要的资源从而由运行状态转换而来,但是该资源不包括<code>CPU</code>时间,缺少<code>CPU</code> 时间会从运行态转换为就绪态.</li>
</ul>
</blockquote>
<h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><p>不同环境的调度算法目标不同,因此需要针对不同环境来讨论调度算法.</p>
<h3 id="1-批处理系统"><a href="#1-批处理系统" class="headerlink" title="1. 批处理系统"></a>1. 批处理系统</h3><p>批处理系统没有太多的用户操作,该系统中,调度算法目标是保证吞吐量和周转时间(从提交到终止的时间).</p>
<h4 id="1-1-先来先服务-first-come-fist-serverd-FCFS"><a href="#1-1-先来先服务-first-come-fist-serverd-FCFS" class="headerlink" title="1.1 先来先服务(first-come-fist-serverd FCFS)"></a><span id="FCFS">1.1 先来先服务(first-come-fist-serverd FCFS)</span></h4><p>非抢占式的调度算法,按照顺序进行调度.</p>
<p>有利于长作业,但不利于短作业,因为短作业必须一直等待前面的长作业执行完毕才能执行,而长作业又需要执行很长的时间,造成了短作业等待的时间过长.</p>
<p>最优状态,耗时短的作业先被执行:</p>
<pre class="mermaid">sequenceDiagram
    participant work_short_time_1
    participant work_short_time_2
    participant work_long_time_1
    participant worl_long_time_2</pre>

<p>最不利状态,耗时的作业一直占用 <code>CPU</code>,使得最短作业始终无法完成:</p>
<pre class="mermaid">sequenceDiagram
participant work_long_time_1
participant worl_long_time_2
participant work_short_time_1
participant work_short_time_2</pre>



<h4 id="1-2-短作业优先-shortest-job-fist-SJF"><a href="#1-2-短作业优先-shortest-job-fist-SJF" class="headerlink" title="1.2 短作业优先(shortest-job-fist SJF)"></a>1.2 短作业优先(shortest-job-fist SJF)</h4><p>非抢占式的掉段算法,按估计运行时间最短的顺序进行调度.</p>
<p>长作业有可能会饿死,处于一直等待短作业执行完毕的状态.因为如果一直有短作业到来,那么长作业永远得不到调度.</p>
<p>比较优的状态,耗时短的任务总量少于长任务,这样让作业更多的占比完成:</p>
<pre class="mermaid">sequenceDiagram
participant work_short_time
participant work_short_time
participant work_long_time</pre>

<p>不利状态,耗时短的任务总量远大于长任务,那么这样饿死的就是相对较短的长任务了🎃:</p>
<pre class="mermaid">sequenceDiagram
    participant work_short_time
    participant work_short_time_2
    participant .....一堆短任务
    participant work_long_time_1
    participant work_long_time_2</pre>



<h4 id="1-3-最短剩余时间优先-shortest-remaining-time-time-next-SRTN"><a href="#1-3-最短剩余时间优先-shortest-remaining-time-time-next-SRTN" class="headerlink" title="1.3 最短剩余时间优先(shortest remaining time time next SRTN)"></a>1.3 最短剩余时间优先(shortest remaining time time next SRTN)</h4><p>最短作业优先的抢占式版本,按剩余运行时间的顺序调度,当一个新作也到达时,其整个运行时间与当前进程的剩余时间作比较,如果新的进程需要的时间更少,则挂起当前进程,运行新的进程,否则新的进程等待.</p>
<h3 id="2-交互式系统"><a href="#2-交互式系统" class="headerlink" title="2.交互式系统"></a>2.交互式系统</h3><pre class="mermaid">graph LR
Center(调度算法)
RoundRobin(时间片轮转算法)
Priority(优先级算法)
Feedback(多级反馈队列调度算法)
Center--&gt;RoundRobin
Center--&gt;Priority
Center--&gt;Feedback</pre>



<blockquote>
<p>交互式系统又大量的用户交互操作,在该系统中调度算法的目标是快速地进行响应.</p>
</blockquote>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><h4 id="2-1-时间片轮转"><a href="#2-1-时间片轮转" class="headerlink" title="2.1 时间片轮转"></a>2.1 时间片轮转</h4><blockquote>
<p>将所有的就绪进程按照<a href="#FCFS">FCFS</a> 的原则排成一个队列,每次调度时,把<code>CPU</code>时间分配给对首进程,该进程可以执行一个时间片.当时间片用完时,由计时器发出时钟中断,调度程序便停止该进程的执行,并将它送往就绪队列的末尾,同时继续把CPU时间分配给队列的末尾,同时继续把CPU时间分配给队首的进程.</p>
<p>时间片轮转算法的效率和时间片的大小很有关系:</p>
<ul>
<li>因为进程切换都要保存进程的信息并且载入新进程的信息,若时间片太小,会导致进程切换得太频繁,在进程切换上就会花很多时间.</li>
<li>而如果时间片过长,那么实时性就不能得到保证</li>
</ul>
</blockquote>
<p>该算法中,将一个较小时间单元定义为时间量或时间片,时间片得大小通常为 <strong>10-100ms</strong> .就绪队列作为循环队列,<code>CPU</code> 调度程序循环真个就绪队列,为每个进程分配不超过一个时间片的 <code>CPU</code>.</p>
<p>为了实现 RR 调度,先将就绪队列视为进程的 <code>FIFO</code> 队列,新进程添加到就绪对列的尾部,<code>CPU</code> 调度程序从就绪对列中选择第一个进程,将定时器设置在一个时间片后中断,最后分派这个进程.</p>
<p>之后将可能出现两种情况..经常可能只需要少于时间片的 <code>CPU</code> 的任务执行.对于这种情况,进程本身会自动释放 <code>CPU</code>,调度程序将接着处理就绪对列的下一个进程.否则,如果当前运行进程的 <code>CPU</code>执行大于一个时间片,那么定时器肯定会中断(超时),进而中断操作系统.然后,进行上下文切换,再将进程加到就绪对列的尾部,接着 <code>CPU</code> 调度程序会选择就绪队列的下一个进程.</p>
<blockquote>
<p>前面提到过,一个进程块保留有进程信息,在中断之后,可以用来恢复上下文环境.</p>
</blockquote>
<p>不过,采用 RR 策略的平均等待时间通常较长,如果有如下状况的几组任务,他们在时间 0 到达.</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>执行时间</th>
</tr>
</thead>
<tbody><tr>
<td>P<del>1</del></td>
<td>24</td>
</tr>
<tr>
<td>P<del>2</del></td>
<td>3</td>
</tr>
<tr>
<td>P<del>3</del></td>
<td>3</td>
</tr>
</tbody></table>
<p>如果使用 <strong>4ms</strong> 的(CPU)时间片,那么 <code>Task_A</code> 会执行最初的 <code>4ms</code>,由于它还需要 <code>20ms</code>,所以在第一个时间片之后,他会被抢占,而 <code>CPU</code> 就交给对列中的下一个进程(P<del>2</del>),由于 P<del>2</del> 不需要一个时间片,所以其他时间片用完之前就会退出.<code>CPU</code> 又交给了进程 P<del>1</del> 以便继续执行</p>
<pre class="mermaid">sequenceDiagram
    participant timer
    participant P1 as P1(24)
    participant P2 as P2(3) 
    participant P3 as P3(3)
    timer -&gt;&gt; P1: 时间片
    
    loop 完成 4ms 的任务
        P1 --&gt; P1: 
    end 
    
    P1 -&gt;&gt; P2: 时间片
    
    loop 完成 4ms 的任务
        P2 --&gt;&gt; P2: 时间片大于3提前退出
    end
    
    P2-&gt;&gt;P3: 时间片
    loop 完成 4ms 的任务
        P3--&gt;P3: 时间片大于3提前退出
    end
    
    P3-&gt;P1: 时间片
    loop 队列已空,持续完成该任务
        P1 --&gt; P1: 
    end</pre>

<p><img lazyload="" src="/images/loading.svg" data-src="http://c.biancheng.net/uploads/allimg/181106/2-1Q10615295H44.gif" alt="时间片轮转调度结果"></p>
<p>计算这个调度的平均等待时间,P<del>1</del>等待了 <mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="35.131ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 15528 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path></g><g data-mml-node="mo" transform="translate(1222.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(2222.4,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><g data-mml-node="mo" transform="translate(2722.4,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(3111.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">从</text></g><g data-mml-node="mi" transform="translate(4111.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">第</text></g><g data-mml-node="mn" transform="translate(5111.4,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><g data-mml-node="mi" transform="translate(5611.4,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(6489.4,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(6958.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">就</text></g><g data-mml-node="mi" transform="translate(7958.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">开</text></g><g data-mml-node="mi" transform="translate(8958.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">始</text></g><g data-mml-node="mi" transform="translate(9958.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">等</text></g><g data-mml-node="mi" transform="translate(10958.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">待</text></g><g data-mml-node="mo" transform="translate(11958.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(12625.2,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(13681,0)"><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z"></path></g><g data-mml-node="mi" transform="translate(14181,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(15059,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g></g></g></svg></mjx-container>,P<del>2</del>等待了 <strong>4ms</strong> ,而 P<del>3</del> 等待了 <strong>7ms</strong> ,因此平均等待时间为 <mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="14.612ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 6458.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z" transform="translate(500,0)"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1000,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path></g></g><g data-mml-node="mn" transform="translate(1500,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><g data-mml-node="mo" transform="translate(2277.8,0)"><path data-c="2248" d="M55 319Q55 360 72 393T114 444T163 472T205 482Q207 482 213 482T223 483Q262 483 296 468T393 413L443 381Q502 346 553 346Q609 346 649 375T694 454Q694 465 698 474T708 483Q722 483 722 452Q722 386 675 338T555 289Q514 289 468 310T388 357T308 404T224 426Q164 426 125 393T83 318Q81 289 69 289Q55 289 55 319ZM55 85Q55 126 72 159T114 210T163 238T205 248Q207 248 213 248T223 249Q262 249 296 234T393 179L443 147Q502 112 553 112Q609 112 649 141T694 220Q694 249 708 249T722 217Q722 153 675 104T555 55Q514 55 468 76T388 123T308 170T224 192Q164 192 125 159T83 84Q80 55 69 55Q55 55 55 85Z"></path></g><g data-mml-node="mn" transform="translate(3333.6,0)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500,0)"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(778,0)"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(1278,0)"></path></g><g data-mml-node="mi" transform="translate(5111.6,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(5989.6,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g></g></g></svg></mjx-container> .</p>
<p>在 RR 调度算法中,没有进程被连续分配超过一个时间片的 CPU(除非他是对列中唯一可运行的进程).如果进程的 <code>CPU</code> 执行进程超过一个时间片,那么该进程会被抢占,并被放回到就绪对列,因此,RR 调度算法是抢占的.</p>
<h4 id="2-2-优先级调度"><a href="#2-2-优先级调度" class="headerlink" title="2.2 优先级调度"></a>2.2 优先级调度</h4><p>为每一个进程,按优先级进行调度.</p>
<p>为了防止低优先级永远等不到调度,可以随着时间的推移增加等待进程的优先级.</p>
<p>对于优先级调度,进一步可以被划分为非抢占式优先级调度算法和抢占式优先级.</p>
<h4 id="2-3-多级反馈队列"><a href="#2-3-多级反馈队列" class="headerlink" title="2.3 多级反馈队列"></a>2.3 多级反馈队列</h4><p>一个进程需要 100 个时间片,如果采用<code>RR</code> ,那么需要交换 100 次.</p>
<p>多级队列是为这种需要连续执行多个时间片的进程考虑的,它设置了多个队列,每个队列时间片大小都不同,列如 1,2,4,8,..…进程在第一个队列没执行完,就会被移到下一个队列.这种方式下,之前的进程只需要交换 7 次.</p>
<p>每个队列的优先权也不同,最上面的优先权最高.因此只有上一个队列没有进程在排队,才能调度当前队列上的进程.</p>
<p>可以将这种算法看作是 RR 和优先级调度算法的结合.</p>
<p>对于优先级最低的队列来说,里面遵循的是 <code>RR</code> .也就是说,位于队列中有  M 个作业,他们的运行时间是通过队列所设定的时间片来确定的;对于其他队列,遵循的是<code>FIFS</code>,每一个进程分配一定的时间片,若时间片进程未结束,则进入下一优先级队列的末尾.</p>
<p>各个队列的时间片是随着优先级的增加而减少的,也就是说,优先级越高的队列中他的时间片越短,同时,为了便于那些超大作业的完成,最后一个队列的时间片一般不大.</p>
]]></content>
      <tags>
        <tag>基础知识</tag>
        <tag>操作系统</tag>
        <tag>进程管理</tag>
      </tags>
  </entry>
</search>
